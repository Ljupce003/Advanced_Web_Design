<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-11-07 Mon 10:58 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Javascript - Reintroduction for programmers</title>
<meta name="author" content="Advanced Web Design - https://www.finki.ukim.mk/" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Javascript - Reintroduction for programmers</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgeb4a5b3">1. Overview</a></li>
<li><a href="#orgd3d15fb">2. Pre-coding Tips</a>
<ul>
<li><a href="#org9742009">2.1. Know your enemy: Browser types</a></li>
<li><a href="#org2d41b46">2.2. Choose the modern DOCTYPE</a></li>
<li><a href="#org260416a">2.3. Resources</a></li>
<li><a href="#org6b576fe">2.4. Incompatibilities</a></li>
<li><a href="#orgb274e51">2.5. The ECMAScript specification</a></li>
</ul>
</li>
<li><a href="#org2b4d5fc">3. Reserved Words</a></li>
<li><a href="#org196f522">4. Syntax Basics</a>
<ul>
<li><a href="#orga79b596">4.1. A simple variable declaration</a></li>
<li><a href="#orge70db2a">4.2. Comments</a></li>
<li><a href="#org8de6e42">4.3. Whitespace has no meaning outside of quotation marks</a></li>
<li><a href="#orgb215b4e">4.4. Parentheses indicate precedence</a></li>
<li><a href="#org710cef2">4.5. Tabs enhance readability, but have no special meaning</a></li>
<li><a href="#orged31f96">4.6. Semicolons</a></li>
<li><a href="#org8baf8f9">4.7. Strict mode</a></li>
</ul>
</li>
<li><a href="#org2086d83">5. Types and Variables</a></li>
<li><a href="#org0d43aab">6. Conditional Code</a>
<ul>
<li><a href="#orgb0af1af">6.1. Note</a></li>
<li><a href="#orgc1e3f5a">6.2. Truthy and falsey things</a></li>
<li><a href="#org1cab9f7">6.3. Conditional Variable Assignment with The Ternary Operator</a></li>
<li><a href="#org6b4892e">6.4. Switch Statements</a></li>
</ul>
</li>
<li><a href="#org57168d5">7. Loops</a>
<ul>
<li><a href="#orgf7c4b2a">7.1. The for loop</a></li>
<li><a href="#orgab35faf">7.2. The while loop</a></li>
<li><a href="#org8c95197">7.3. The do-while loop</a></li>
<li><a href="#org1d223e3">7.4. Breaking and continuing</a></li>
</ul>
</li>
<li><a href="#org55cd9b9">8. Operators</a>
<ul>
<li><a href="#org93ea492">8.1. Basic Operators</a></li>
<li><a href="#orgf00a9b2">8.2. Operations on Numbers &amp; Strings and type coercion</a></li>
<li><a href="#orgdfa8d30">8.3. Logical Operators</a></li>
<li><a href="#org1af48bf">8.4. Note</a></li>
<li><a href="#org6e5416b">8.5. Comparison Operators</a></li>
<li><a href="#org661dadb">8.6. Operator precedence and associativity:</a></li>
</ul>
</li>
<li><a href="#org0512b4c">9. Arrays</a></li>
<li><a href="#orga30daac">10. Important concepts</a>
<ul>
<li><a href="#orgcc8ea84">10.1. Syntax Parser (SP)</a></li>
<li><a href="#org5165061">10.2. Execution Context (EC)</a></li>
<li><a href="#orgc19819f">10.3. Execution Stack (ES)</a></li>
<li><a href="#org04c4b94">10.4. Lexical Environment</a>
<ul>
<li><a href="#orge85a96b">10.4.1. Environment Record</a></li>
<li><a href="#org587c50d">10.4.2. Reference to the Outer Environment</a></li>
<li><a href="#org0b7f243">10.4.3. This Binding</a></li>
</ul>
</li>
<li><a href="#orgc8ee34f">10.5. Name-Value Pair and Objects</a></li>
<li><a href="#org1c6af84">10.6. Global Environment and The Global Object</a></li>
<li><a href="#org1364f59">10.7. Hoisting and creating execution context</a>
<ul>
<li><a href="#org31216dd">10.7.1. Creation phase</a></li>
<li><a href="#org470e192">10.7.2. Execution phase</a></li>
</ul>
</li>
<li><a href="#orga96cdeb">10.8. Execution Stack, Function Invocation and Variable environment</a></li>
</ul>
</li>
<li><a href="#org9417efd">11. Scope and the scope chain</a>
<ul>
<li><a href="#org70f0aa0">11.1. Variable declaration: var, const, let</a>
<ul>
<li><a href="#orgba6eda2">11.1.1. Short explanation</a></li>
<li><a href="#org31577b0">11.1.2. <code>var</code> keyword</a></li>
<li><a href="#orgaafc217">11.1.3. <code>let</code> keyword</a></li>
<li><a href="#org3cafce0">11.1.4. <code>const</code> keyword</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8ecefb4">12. Functions</a>
<ul>
<li><a href="#org8afaaab">12.1. Function Statements vs function expressions</a></li>
<li><a href="#org92b0239">12.2. References and values</a></li>
<li><a href="#orgaa0330b">12.3. The <code>this</code> keyword, objects and functions</a></li>
<li><a href="#orgbb7869a">12.4. Arguments and spread</a></li>
<li><a href="#org955ebf5">12.5. Immediately invoked function expression and  Self-Executing Anonymous Functions</a></li>
<li><a href="#org2e51a68">12.6. Functions as Arguments</a></li>
</ul>
</li>
<li><a href="#org09c1971">13. Objects in depth</a>
<ul>
<li><a href="#org20b707f">13.1. The Comupted Member Access Operator</a></li>
<li><a href="#org856af28">13.2. Faking namespaces in JavaScript</a></li>
<li><a href="#org6bfd9a7">13.3. Note</a></li>
</ul>
</li>
<li><a href="#org424516f">14. Closures</a>
<ul>
<li><a href="#org043c5df">14.1. Closure Examples</a></li>
</ul>
</li>
<li><a href="#orgabb5a65">15. Testing Type</a></li>
<li><a href="#orgdcd1e61">16. Prototype-based programming</a>
<ul>
<li><a href="#org3d3abbb">16.1. Standard built-in objects</a></li>
<li><a href="#org1299d0f">16.2. Custom objects</a></li>
<li><a href="#org58c80e7">16.3. The object (class instance)</a></li>
<li><a href="#orgb4fdda6">16.4. The constructor</a></li>
<li><a href="#org1f428e4">16.5. The methods</a></li>
<li><a href="#org7eecbd8">16.6. Inheritance</a></li>
<li><a href="#org8056187">16.7. Encapsulation</a></li>
<li><a href="#orge3e16a0">16.8. Abstraction</a></li>
<li><a href="#org762c8e5">16.9. Polymorphism</a></li>
<li><a href="#org944aeb1">16.10. Real World Examples</a></li>
</ul>
</li>
<li><a href="#orga0ac1e2">17. EcmaScript 2015 (ES6) and beyond</a>
<ul>
<li><a href="#org1fe9e91">17.1. Arrow functions</a>
<ul>
<li><a href="#org2676c9e">17.1.1. In detail</a></li>
<li><a href="#org4545847">17.1.2. Concision and implicit return</a></li>
<li><a href="#org96bcd81">17.1.3. <i>this</i> reference</a></li>
</ul>
</li>
<li><a href="#org24eca07">17.2. Function default parameter value</a></li>
<li><a href="#orga07edc7">17.3. Destructuring objects and arrays</a>
<ul>
<li><a href="#orge44bdd9">17.3.1. Object</a></li>
<li><a href="#org84c1dbb">17.3.2. Function parameters</a></li>
<li><a href="#org745ac98">17.3.3. Array</a></li>
</ul>
</li>
<li><a href="#org909a83b">17.4. Array methods - map / filter / reduce</a></li>
<li><a href="#org5c53f82">17.5. Spread operator &ldquo;&#x2026;&rdquo;</a>
<ul>
<li><a href="#org0b0db50">17.5.1. In iterables (like arrays) :: If we have the two following arrays:</a></li>
<li><a href="#org06d9b09">17.5.2. Function rest parameter</a></li>
<li><a href="#org44c969a">17.5.3. Object properties spreading</a></li>
</ul>
</li>
<li><a href="#org578340d">17.6. Iterators + For..Of</a></li>
<li><a href="#orgde631f5">17.7. Symbols</a></li>
<li><a href="#org52c113c">17.8. Subclassable Built-ins</a></li>
<li><a href="#orgacefe9f">17.9. Object property shorthand</a></li>
<li><a href="#org69a014e">17.10. Promises</a>
<ul>
<li><a href="#org4bf95c1">17.10.1. Create the promise</a></li>
<li><a href="#orgeb242db">17.10.2. Promise handlers usage</a></li>
</ul>
</li>
<li><a href="#org2132163">17.11. Template literals</a></li>
<li><a href="#orgc9cb5ba">17.12. Tagged template literals</a></li>
<li><a href="#org8a04934">17.13. Imports / Exports</a>
<ul>
<li><a href="#org891dab5">17.13.1. Named exports</a></li>
<li><a href="#org70b3511">17.13.2. Default import / export</a></li>
</ul>
</li>
<li><a href="#orgf44c2b0">17.14. Classes in ES6</a></li>
<li><a href="#org7190823">17.15. <code>Extends</code> and <code>super</code> keywords</a></li>
<li><a href="#orgaa42864">17.16. Async Await</a>
<ul>
<li><a href="#org2342398">17.16.1. Error handling</a></li>
</ul>
</li>
<li><a href="#org7eca713">17.17. Generators</a></li>
<li><a href="#orgdf093e5">17.18. Static Methods</a>
<ul>
<li><a href="#org031d719">17.18.1. Calling other static methods from a static method.</a></li>
<li><a href="#orgf95925c">17.18.2. Calling static methods from non-static methods.</a></li>
</ul>
</li>
<li><a href="#orgdb7cd70">17.19. Binary and Octal Literals</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgeb4a5b3" class="outline-2">
<h2 id="orgeb4a5b3"><span class="section-number-2">1.</span> Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
JavaScript is a rich and expressive language in its own right. This
section covers the basic concepts of JavaScript, as well as some
frequent pitfalls for people who have not used JavaScript before. While
it will be of particular value to people with no programming experience,
even people who have used other programming languages may benefit from
learning about some of the peculiarities of JavaScript.
</p>

<p>
JavaScript has <b>nothing in common with  Java</b>. It is a completely different
language with a similar  naming. JavaScript has the language specification
called <a href="http://en.wikipedia.org/wiki/ECMAScript">ECMAScript</a>.
</p>

<p>
If you&rsquo;re interested in learning more about the JavaScript language in its
older variants, the book <i>JavaScript: The Good Parts</i> by Douglas Crockford is
highly recommended.
</p>
</div>
</div>

<div id="outline-container-orgd3d15fb" class="outline-2">
<h2 id="orgd3d15fb"><span class="section-number-2">2.</span> Pre-coding Tips</h2>
<div class="outline-text-2" id="text-2">
<p>
There are currently several main JavaScript/html rendering engines
available. A regular web-site should look equally good in all of
them.
</p>
</div>
<div id="outline-container-org9742009" class="outline-3">
<h3 id="org9742009"><span class="section-number-3">2.1.</span> Know your enemy: Browser types</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>Firefox and other browsers based on it use an open-source
rendering engine called Gecko. Firefox&rsquo;s JavaScript engine is called
SpiderMonkey.</li>

<li>Safari and older version of Chromium based browsers (before v.28) used an
open-source rendering engine called Webkit. They always used different
JavaScript implementations. Safari uses it’s own closed-source JavaScript
engine (called JavaScriptCore, Nitro or SquirrelFish).</li>

<li>Chrome (after v.28) and other browsers based on the Chroimium project use
the Blink rendering engine, a fork of WebKit. Chrome uses Google V8
JavaScript engine.</li>

<li>Modern version of Opera use the Blink/V8 combination. Older versions of
Opera (until v.12) used it’s closed source rendering engine called Presto
and JavaScript engine Carakan.</li>

<li>Internet Explorer uses the closed-source engine called
Trident. The engine is old and terrifying in IE6, IE7, but
upgraded in IE8 and upgraded to much better standards compliance
in IE9 and later versions. Its JavaScript engine is called Chakra.
IE is discontinued with Windows 10.</li>

<li>Microsoft Edge is the novel browser from Microsoft that <i>used</i> the EdgeHTML
rendering engine and updated versions of the Chakra JavaScript Engine.
Since 2018 Microsoft changed the internals of Edge to Blink/V8 combination.</li>
</ul>

<p>
Sometimes, the cross-browser development becomes complicated, so
browsers are graded according to the level of support in descending order.
</p>

<dl class="org-dl">
<dt>Latest Safari(WebKit)/Chrome(Blink) based browsers</dt><dd>Supported ideally.</dd>
<dt>Latest Firefox(Gecko) based browsers</dt><dd>Next support target.</dd>
<dt>Less recent non Webkit/Blink/Gecko based major browsers</dt><dd>Supported well enough, but
minor drawbacks in look and feel are possible.</dd>
<dt>Old major browsers</dt><dd>Only the core functionality of the site is supported.</dd>
<dt>Very old. Text browsers.</dt><dd>Not supported. If it works, it
works. If it doesn’t, no one cares.</dd>
</dl>

<p>
The grading above is an example from real life.
</p>
</div>
</div>

<div id="outline-container-org2d41b46" class="outline-3">
<h3 id="org2d41b46"><span class="section-number-3">2.2.</span> Choose the modern DOCTYPE</h3>
<div class="outline-text-3" id="text-2-2">
<p>
As you probably already know from HTML, there are two main
rendering modes: Standards Mode (Strict Mode) and Quirks mode. Actually, there
is a third mode called Almost Standards Mode, all of them
described well in <a href="http://en.wikipedia.org/wiki/Quirks_mode">Wikipedia quirks mode</a> page.
</p>

<p>
Browser chooses the mode according to DOCTYPE header of HTML.
</p>

<p>
For modern sites there is a good DOCTYPE:
</p>
<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #51afef;">!DOCTYPE</span> HTML&gt;
</pre>
</div>

<p>
This DOCTYPE make modern browsers render in Standards Mode and
older ones in Almost Standards Mode (which is the maximum they can
do).
</p>

<p>
Note, that the modern rendering mode is not just an HTML
issue. There are JavaScript properties which also depend on the
rendering mode, especially CSS-box and positioning-related.
</p>

<p>
Not using correct DOCTYPE will cost you time debugging. <code>&lt;!DOCTYPE HTML&gt;</code> is ok.
</p>
</div>
</div>

<div id="outline-container-org260416a" class="outline-3">
<h3 id="org260416a"><span class="section-number-3">2.3.</span> Resources</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Main manual on the net about JavaScript - the documentation center of <a href="https://developer.mozilla.org/">Mozilla Developer Network (MDN)</a>.
</p>

<p>
MDN is usually good for general and firefox-specific information.
</p>
</div>
</div>

<div id="outline-container-org6b576fe" class="outline-3">
<h3 id="org6b576fe"><span class="section-number-3">2.4.</span> Incompatibilities</h3>
<div class="outline-text-3" id="text-2-4">
<p>
There are many cross-browser incompatibilities in
frontend-programming. When you come across them,
<a href="http://www.quirksmode.org/">http://www.quirksmode.org/</a> may be a help.  It contains
information about lots of incompatibilities. Also, there is a
combo to search it. Try entering &ldquo;quirksmode onkeypress&rdquo; in
google for instance.
</p>
</div>
</div>

<div id="outline-container-orgb274e51" class="outline-3">
<h3 id="orgb274e51"><span class="section-number-3">2.5.</span> The ECMAScript specification</h3>
<div class="outline-text-3" id="text-2-5">
<p>
The language specification (formal description of syntax, basic objects and algorithms) of JavaScript is called <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript</a>.
</p>

<p>
The language specification tells a lot about how it works, but it is an advanced source of information.
</p>

<p>
Today we live in a time of changes. The modern standard can be traced to <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262 16th edition</a>.
The implementation of new EcmaScript features can be tracked on <a href="https://www.ecma-international.org/technical-committees/tc39">TC39 section</a> of ecma international.
</p>

<p>
When you want to learn how the language works in-depth, there’s more perspective in reading new versions of ES, but remember that many features
are not implemented yet. You can find a list of supported browsers/features for important JS versions at <a href="http://kangax.github.io/compat-table">http://kangax.github.io/compat-table</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-org2b4d5fc" class="outline-2">
<h2 id="org2b4d5fc"><span class="section-number-2">3.</span> Reserved Words</h2>
<div class="outline-text-2" id="text-3">
<p>
JavaScript has a number of &ldquo;reserved words&rdquo;, or words that have special
meaning in the language. You should avoid using these words in your code
except when using them with their intended meaning.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>abstract</code></td>
<td class="org-left"><code>boolean</code></td>
<td class="org-left"><code>break</code></td>
<td class="org-left"><code>byte</code></td>
</tr>

<tr>
<td class="org-left"><code>case</code></td>
<td class="org-left"><code>catch</code></td>
<td class="org-left"><code>char</code></td>
<td class="org-left"><code>class</code></td>
</tr>

<tr>
<td class="org-left"><code>const</code></td>
<td class="org-left"><code>continue</code></td>
<td class="org-left"><code>debugger</code></td>
<td class="org-left"><code>default</code></td>
</tr>

<tr>
<td class="org-left"><code>delete</code></td>
<td class="org-left"><code>do</code></td>
<td class="org-left"><code>double</code></td>
<td class="org-left"><code>else</code></td>
</tr>

<tr>
<td class="org-left"><code>enum</code></td>
<td class="org-left"><code>export</code></td>
<td class="org-left"><code>extends</code></td>
<td class="org-left"><code>final</code></td>
</tr>

<tr>
<td class="org-left"><code>finally</code></td>
<td class="org-left"><code>float</code></td>
<td class="org-left"><code>for</code></td>
<td class="org-left"><code>function</code></td>
</tr>

<tr>
<td class="org-left"><code>goto</code></td>
<td class="org-left"><code>if</code></td>
<td class="org-left"><code>implements</code></td>
<td class="org-left"><code>import</code></td>
</tr>

<tr>
<td class="org-left"><code>in</code></td>
<td class="org-left"><code>instanceof</code></td>
<td class="org-left"><code>int</code></td>
<td class="org-left"><code>interface</code></td>
</tr>

<tr>
<td class="org-left"><code>long</code></td>
<td class="org-left"><code>native</code></td>
<td class="org-left"><code>new</code></td>
<td class="org-left"><code>package</code></td>
</tr>

<tr>
<td class="org-left"><code>private</code></td>
<td class="org-left"><code>protected</code></td>
<td class="org-left"><code>public</code></td>
<td class="org-left"><code>return</code></td>
</tr>

<tr>
<td class="org-left"><code>short</code></td>
<td class="org-left"><code>static</code></td>
<td class="org-left"><code>super</code></td>
<td class="org-left"><code>switch</code></td>
</tr>

<tr>
<td class="org-left"><code>synchronized</code></td>
<td class="org-left"><code>this</code></td>
<td class="org-left"><code>throw</code></td>
<td class="org-left"><code>throws</code></td>
</tr>

<tr>
<td class="org-left"><code>transient</code></td>
<td class="org-left"><code>try</code></td>
<td class="org-left"><code>typeof</code></td>
<td class="org-left"><code>var</code></td>
</tr>

<tr>
<td class="org-left"><code>void</code></td>
<td class="org-left"><code>volatile</code></td>
<td class="org-left"><code>while</code></td>
<td class="org-left"><code>with</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org196f522" class="outline-2">
<h2 id="org196f522"><span class="section-number-2">4.</span> Syntax Basics</h2>
<div class="outline-text-2" id="text-4">
<p>
Understanding statements, variable naming, whitespace, and other basic
JavaScript syntax.
</p>
</div>

<div id="outline-container-orga79b596" class="outline-3">
<h3 id="orga79b596"><span class="section-number-3">4.1.</span> A simple variable declaration</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The oldest way to declare variable is by using <code>var</code>:
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">var</span> <span style="color: #dcaeea;">foo</span> = <span style="color: #98be65;">'hello world'</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;"> declare local/global variables</span>
foo = <span style="color: #da8548; font-weight: bold;">200</span>;
</pre>
</div>

<p>
From ES6, the preferred way of declaring varables is using the <code>const</code> and <code>let</code> keywords.
In the spirit of ES standard evolution, correcting <i>controversial</i> language aspects are done in a backwards-comaptible way.
<code>const</code> creates a constant binding to a variable while <code>let</code> creates standard non-constant variable (similar to <code>var</code>). Both const and let are block-scoped, unlike var which is function-scoped.
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">const</span> <span style="color: #dcaeea;">constant_variable</span> = <span style="color: #da8548; font-weight: bold;">100</span>;

constant_variable = <span style="color: #da8548; font-weight: bold;">0</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Error, constant binding...</span>

<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">variable</span> = <span style="color: #da8548; font-weight: bold;">100</span>;
variable = <span style="color: #da8548; font-weight: bold;">0</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">perfectly legal</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge70db2a" class="outline-3">
<h3 id="orge70db2a"><span class="section-number-3">4.2.</span> Comments</h3>
<div class="outline-text-3" id="text-4-2">
<p>
One-line comments start with two forward slash characters <code>//</code>.
The rest of the line is a comment. It may occupy a full line of its own or follow a statement.
</p>

<p>
Multiline comments start with a forward slash and an asterisk <code>/*</code> and end with an asterisk and a forward slash <code>*/</code>.
</p>
</div>
</div>


<div id="outline-container-org8de6e42" class="outline-3">
<h3 id="org8de6e42"><span class="section-number-3">4.3.</span> Whitespace has no meaning outside of quotation marks</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">var</span> <span style="color: #dcaeea;">foo</span> =         <span style="color: #98be65;">'hello world'</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb215b4e" class="outline-3">
<h3 id="orgb215b4e"><span class="section-number-3">4.4.</span> Parentheses indicate precedence</h3>
<div class="outline-text-3" id="text-4-4">
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #da8548; font-weight: bold;">2</span> * <span style="color: #da8548; font-weight: bold;">3</span> + <span style="color: #da8548; font-weight: bold;">5</span>;    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 11; multiplication happens first</span>
<span style="color: #da8548; font-weight: bold;">2</span> * (<span style="color: #da8548; font-weight: bold;">3</span> + <span style="color: #da8548; font-weight: bold;">5</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 16; addition happens first</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org710cef2" class="outline-3">
<h3 id="org710cef2"><span class="section-number-3">4.5.</span> Tabs enhance readability, but have no special meaning</h3>
<div class="outline-text-3" id="text-4-5">
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">var</span> <span style="color: #dcaeea;">foo</span> = <span style="color: #51afef;">function</span>() {
  console.log(<span style="color: #98be65;">'hello'</span>);
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orged31f96" class="outline-3">
<h3 id="orged31f96"><span class="section-number-3">4.6.</span> Semicolons</h3>
<div class="outline-text-3" id="text-4-6">
<p>
A semicolon may be omitted in most cases when a line break exists. This would also work:
</p>

<div class="org-src-container">
<pre class="src src-javascript">alert(<span style="color: #98be65;">'Hello'</span>)
alert(<span style="color: #98be65;">'World'</span>)
</pre>
</div>

<p>
Here, JavaScript interprets the line break as an &ldquo;implicit&rdquo; semicolon. This is called an <b>automatic semicolon insertion</b>.
In most cases, a newline implies a semicolon. But &ldquo;in most cases&rdquo; does not mean &ldquo;always&rdquo;!
</p>
</div>
</div>

<div id="outline-container-org8baf8f9" class="outline-3">
<h3 id="org8baf8f9"><span class="section-number-3">4.7.</span> Strict mode</h3>
<div class="outline-text-3" id="text-4-7">
<p>
For a long time, JavaScript evolved without compatibility issues. New features were added to the language while old functionality didn’t change.
That had the benefit of never breaking existing code. But the downside was that any mistake or an imperfect decision made by JavaScript’s creators got stuck in the language forever.
</p>

<p>
This was the case until 2009 when ECMAScript 5 (ES5) appeared. It added new features to the language and modified some of the existing ones. To keep the old code working, most such modifications are off by default. You need to explicitly enable them with a special directive: <code>"use strict"</code>.
</p>

<p>
The directive looks like a string: <code>"use strict"</code> or <code>'use strict'</code>. When it is located at the top of a script, the whole script works the &ldquo;modern&rdquo; way.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #98be65;">"use strict"</span>;

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">this code works the modern way</span>
...
</pre>
</div>

<p>
Quite soon we’re going to learn functions (a way to group commands), so let’s note in advance that <code>"use strict"</code> can be put at the beginning of a function. Doing that enables strict mode in that function only. But usually people use it for the whole script.
</p>

<p>
Modern JavaScript supports &ldquo;classes&rdquo; and &ldquo;modules&rdquo; – advanced language structures, that enable use strict automatically. So we don’t need to add the &ldquo;use strict&rdquo; directive, if we use them.
</p>
</div>
</div>
</div>


<div id="outline-container-org2086d83" class="outline-2">
<h2 id="org2086d83"><span class="section-number-2">5.</span> Types and Variables</h2>
<div class="outline-text-2" id="text-5">
<p>
JavaScript is dynamically typed language. This means that the language is responsible for figuring out the type of the variable, during the code execution.
</p>

<p>
There are <b>7 (seven)</b> primitive types in JavaScript:
</p>
<dl class="org-dl">
<dt>undefined</dt><dd>represents lack of existance. A good pattern is to never set a variable to undefined</dd>
<dt>null</dt><dd>also represents lack of existance.</dd>
<dt>boolean</dt><dd>true or false value. (Because JavaScript is case-sensitive, null is not the same as Null, NULL, or any other variant.)</dd>
<dt>number</dt><dd>- an integer or floating point number. <b>There is no integer type.</b>
The consequences of the floating point aritmetics are applied here.</dd>
<dt>string</dt><dd>sequence of characters, specified in single(<code>'</code>) or double quotes(<code>"</code>) and in backticks (<code>`</code>).</dd>
<dt>symbol (ES6+ only)</dt><dd>an unique and immutable data type and may be used as an identifier for object properties</dd>
<dt>BigInt</dt><dd> an integer with arbitrary precision. For example: <code>9007199254740992n</code></dd>
</dl>

<p>
Everythig that is not a primitive type is an object. There are built-in objects that are present with every javascript environment (like Math, Date, Number, RegEx, Array, etc). A comprehensive list is available on the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">MDN website</a>.
</p>

<p>
Double and single quotes are &ldquo;simple&rdquo; quotes. There’s practically no difference between them in JavaScript.
Backticks are &ldquo;extended functionality&rdquo; quotes. They allow us to embed variables and expressions into a string by wrapping them in <code>${…}</code>, for example:
</p>

<div class="org-src-container">
<pre class="src src-javascript">
<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">name</span> = <span style="color: #98be65;">"John"</span>;

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">embed a variable</span>
alert( <span style="color: #98be65;">`Hello, ${name}!`</span> ); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Hello, John!</span>

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">embed an expression</span>
alert( <span style="color: #98be65;">`the result is ${1 + 2}`</span> ); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">the result is 3</span>
</pre>
</div>

<p>
The expression inside <code>${…}</code> is evaluated and the result becomes a part of the string. We can put anything in there: a variable like <code>name</code> or an arithmetical expression like <code>1 + 2</code> or something more complex.
</p>
</div>
</div>

<div id="outline-container-org0d43aab" class="outline-2">
<h2 id="org0d43aab"><span class="section-number-2">6.</span> Conditional Code</h2>
<div class="outline-text-2" id="text-6">
<p>
Sometimes you only want to run a block of code under certain conditions.
Flow control &#x2014; via <code>if</code> and <code>else</code> blocks &#x2014; lets you run code only
under certain conditions.
</p>

<p>
<b>Flow control</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">var</span> <span style="color: #dcaeea;">foo</span> = <span style="color: #a9a1e1;">true</span>;
<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">bar</span> = <span style="color: #a9a1e1;">false</span>;

<span style="color: #51afef;">if</span> (bar) {
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">this code will never run</span>
    console.log(<span style="color: #98be65;">'hello!'</span>);
}

<span style="color: #51afef;">if</span> (bar) {
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">this code won't run</span>
} <span style="color: #51afef;">else</span> {
    <span style="color: #51afef;">if</span> (foo) {
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">this code will run</span>
    } <span style="color: #51afef;">else</span> {
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">this code would run if foo and bar were both false</span>
    }
}
</pre>
</div>
</div>

<div id="outline-container-orgb0af1af" class="outline-3">
<h3 id="orgb0af1af"><span class="section-number-3">6.1.</span> Note</h3>
<div class="outline-text-3" id="text-6-1">
<p>
While curly braces aren&rsquo;t strictly required around single-line <code>if</code>
statements, using them consistently, even when they aren&rsquo;t strictly
required, makes for vastly more readable code.
</p>

<p>
Be mindful not to define functions with the same name multiple times
within separate <code>if=/=else</code> blocks, as doing so may not have the
expected result.
</p>
</div>
</div>

<div id="outline-container-orgc1e3f5a" class="outline-3">
<h3 id="orgc1e3f5a"><span class="section-number-3">6.2.</span> Truthy and falsey things</h3>
<div class="outline-text-3" id="text-6-2">
<p>
In order to use flow control successfully, it&rsquo;s important to understand
which kinds of values are <code>truthy</code> and which kinds of values are
<code>falsy.</code> Sometimes, values that seem like they should evaluate one way
actually evaluate another.
</p>

<p>
<b>Values that evaluate to <code>true</code></b>
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #98be65;">'0'</span>;
<span style="color: #98be65;">'any string'</span>;
[];  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">an empty array</span>
{};  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">an empty object</span>
<span style="color: #da8548; font-weight: bold;">1</span>;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">any non-zero number</span>
</pre>
</div>

<p>
<b>Values that evaluate to <code>false</code></b>
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #da8548; font-weight: bold;">0</span>;
<span style="color: #98be65;">''</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">an empty string</span>
<span style="color: #a9a1e1;">NaN</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">JavaScript's "not-a-number" variable</span>
<span style="color: #a9a1e1;">null</span>;
<span style="color: #a9a1e1;">undefined</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">be careful -- undefined can be redefined!</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org1cab9f7" class="outline-3">
<h3 id="org1cab9f7"><span class="section-number-3">6.3.</span> Conditional Variable Assignment with The Ternary Operator</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Sometimes you want to set a variable to a value depending on some
condition. You could use an <code>if=/=else</code> statement, but in many cases the
ternary operator is more convenient. [Definition: The <i>ternary operator</i>
tests a condition; if the condition is true, it returns a certain value,
otherwise it returns a different value.]
</p>

<p>
<b>The ternary operator</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">set foo to 1 if bar is true;</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">otherwise, set foo to 0</span>
<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">foo</span> = bar ? <span style="color: #da8548; font-weight: bold;">1</span> : <span style="color: #da8548; font-weight: bold;">0</span>;
</pre>
</div>

<p>
While the ternary operator can be used without assigning the return
value to a variable, this is generally discouraged.
</p>
</div>
</div>

<div id="outline-container-org6b4892e" class="outline-3">
<h3 id="org6b4892e"><span class="section-number-3">6.4.</span> Switch Statements</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Rather than using a series of if/else if/else blocks, sometimes it can
be useful to use a switch statement instead. [Definition: <i>Switch
statements</i> look at the value of a variable or expression, and run
different blocks of code depending on the value.]
</p>

<p>
<b>A switch statement</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">switch</span> (foo) {
  <span style="color: #51afef;">case</span> <span style="color: #98be65;">'bar'</span>:
    alert(<span style="color: #98be65;">'the value was bar -- yay!'</span>);
    <span style="color: #51afef;">break</span>;

  <span style="color: #51afef;">case</span> <span style="color: #98be65;">'baz'</span>:
    alert(<span style="color: #98be65;">'boo baz :('</span>);
    <span style="color: #51afef;">break</span>;
  <span style="color: #51afef;">default</span>:
    alert(<span style="color: #98be65;">'everything else is just ok'</span>);
    <span style="color: #51afef;">break</span>;
}
</pre>
</div>

<p>
Switch statements have somewhat fallen out of favor in JavaScript,
because often the same behavior can be accomplished by creating an
object that has more potential for reuse, testing, etc. For example:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">var</span> <span style="color: #dcaeea;">stuffToDo</span> = {
  <span style="color: #98be65;">'bar'</span> : <span style="color: #51afef;">function</span>() {
    alert(<span style="color: #98be65;">'the value was bar -- yay!'</span>);
  },

  <span style="color: #98be65;">'baz'</span> : <span style="color: #51afef;">function</span>() {
    alert(<span style="color: #98be65;">'boo baz :('</span>);
  },

  <span style="color: #98be65;">'default'</span> : <span style="color: #51afef;">function</span>() {
    alert(<span style="color: #98be65;">'everything else is just ok'</span>);
  }
};

<span style="color: #51afef;">if</span> (stuffToDo[foo]) {
  stuffToDo[foo]();
} <span style="color: #51afef;">else</span> {
  stuffToDo[<span style="color: #98be65;">'default'</span>]();
}
</pre>
</div>

<p>
We&rsquo;ll look at objects in greater depth later.
</p>
</div>
</div>
</div>

<div id="outline-container-org57168d5" class="outline-2">
<h2 id="org57168d5"><span class="section-number-2">7.</span> Loops</h2>
<div class="outline-text-2" id="text-7">
<p>
Loops let you run a block of code a certain number of times.
</p>

<p>
<b>Loops</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 'try 0', 'try 1', ..., 'try 4'</span>
<span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span>=<span style="color: #da8548; font-weight: bold;">0</span>; i&lt;<span style="color: #da8548; font-weight: bold;">5</span>; i++) {
    console.log(<span style="color: #98be65;">'try '</span> + i);
}
</pre>
</div>

<p>
Note that in loops even though we use the keyword var before the
variable name <code>i</code>, this does not &ldquo;scope&rdquo; the variable <code>i</code> to the loop
block. We&rsquo;ll discuss scope in depth later in this chapter./
</p>
</div>

<div id="outline-container-orgf7c4b2a" class="outline-3">
<h3 id="orgf7c4b2a"><span class="section-number-3">7.1.</span> The for loop</h3>
<div class="outline-text-3" id="text-7-1">
<p>
A <code>for</code> loop is made up of four statements and has the following
structure:
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">for</span> ([initialisation]; [conditional]; [iteration])
     [loopBody]
</pre>
</div>

<p>
The <i>initialisation</i> statement is executed only once, before the loop
starts. It gives you an opportunity to prepare or declare any variables.
</p>

<p>
The <i>conditional</i> statement is executed before each iteration, and its
return value decides whether or not the loop is to continue. If the
conditional statement evaluates to a falsey value then the loop stops.
</p>

<p>
The <i>iteration</i> statement is executed at the end of each iteration and
gives you an opportunity to change the state of important variables.
Typically, this will involve incrementing or decrementing a counter and
thus bringing the loop ever closer to its end.
</p>

<p>
The <i>loopBody</i> statement is what runs on every iteration. It can contain
anything you want. You&rsquo;ll typically have multiple statements that need
to be executed and so will wrap them in a block ( <code>{...}</code>).
</p>

<p>
Here&rsquo;s a typical <code>for</code> loop:
</p>

<p>
<b>A typical <code>for</code> loop</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">limit</span> = <span style="color: #da8548; font-weight: bold;">100</span>; i &lt; limit; i++) {
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">This block will be executed 100 times</span>
        console.log(<span style="color: #98be65;">'Currently at '</span> + i);
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Note: the last log will be "Currently at 99"</span>
    }
</pre>
</div>
</div>
</div>

<div id="outline-container-orgab35faf" class="outline-3">
<h3 id="orgab35faf"><span class="section-number-3">7.2.</span> The while loop</h3>
<div class="outline-text-3" id="text-7-2">
<p>
A <code>while</code> loop is similar to an <code>if</code> statement, except that its body
will keep executing until the condition evaluates to false.
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">while</span> ([conditional]) [loopBody]
</pre>
</div>

<p>
Here&rsquo;s a typical <code>while</code> loop:
</p>

<p>
<b>A typical <code>while</code> loop</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
    <span style="color: #51afef;">while</span> (i &lt; <span style="color: #da8548; font-weight: bold;">100</span>) {

        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">This block will be executed 100 times</span>
        console.log(<span style="color: #98be65;">'Currently at '</span> + i);

        i++; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">increment i</span>

    }
</pre>
</div>

<p>
You&rsquo;ll notice that we&rsquo;re having to increment the counter within the
loop&rsquo;s body. It is possible to combine the conditional and incrementer,
like so:
</p>

<p>
<b>A <code>while</code> loop with a combined conditional and incrementer</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span> = -<span style="color: #da8548; font-weight: bold;">1</span>;
    <span style="color: #51afef;">while</span> (++i &lt; <span style="color: #da8548; font-weight: bold;">100</span>) {
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">This block will be executed 100 times</span>
        console.log(<span style="color: #98be65;">'Currently at '</span> + i);
    }
</pre>
</div>

<p>
Notice that we&rsquo;re starting at <code>-1</code> and using the prefix incrementer
(<code>++i</code>).
</p>
</div>
</div>

<div id="outline-container-org8c95197" class="outline-3">
<h3 id="org8c95197"><span class="section-number-3">7.3.</span> The do-while loop</h3>
<div class="outline-text-3" id="text-7-3">
<p>
This is almost exactly the same as the <code>while</code> loop, except for the fact
that the loop&rsquo;s body is executed at least once before the condition is
tested.
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">do</span> [loopBody] <span style="color: #51afef;">while</span> ([conditional])
</pre>
</div>

<p>
Here&rsquo;s a <code>do-while</code> loop:
</p>

<p>
<b>A <code>do-while</code> loop</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">do</span> {

        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Even though the condition evaluates to false</span>
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">this loop's body will still execute once.</span>

        alert(<span style="color: #98be65;">'Hi there!'</span>);

    } <span style="color: #51afef;">while</span> (<span style="color: #a9a1e1;">false</span>);
</pre>
</div>

<p>
These types of loops are quite rare since only few situations require a
loop that blindly executes at least once. Regardless, it&rsquo;s good to be
aware of it.
</p>
</div>
</div>

<div id="outline-container-org1d223e3" class="outline-3">
<h3 id="org1d223e3"><span class="section-number-3">7.4.</span> Breaking and continuing</h3>
<div class="outline-text-3" id="text-7-4">
<p>
Usually, a loop&rsquo;s termination will result from the conditional statement
not evaluating to true, but it is possible to stop a loop in its tracks
from within the loop&rsquo;s body with the <code>break</code> statement.
</p>

<p>
<b>Stopping a loop</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">10</span>; i++) {
        <span style="color: #51afef;">if</span> (something) {
            <span style="color: #51afef;">break</span>;
        }
    }
</pre>
</div>

<p>
You may also want to continue the loop without executing more of the
loop&rsquo;s body. This is done using the <code>continue</code> statement.
</p>

<p>
<b>Skipping to the next iteration of a loop</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">10</span>; i++) {

        <span style="color: #51afef;">if</span> (something) {
            <span style="color: #51afef;">continue</span>;
        }

        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">The following statement will only be executed</span>
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">if the conditional 'something' has not been met</span>
        console.log(<span style="color: #98be65;">'I have been reached'</span>);

    }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org55cd9b9" class="outline-2">
<h2 id="org55cd9b9"><span class="section-number-2">8.</span> Operators</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org93ea492" class="outline-3">
<h3 id="org93ea492"><span class="section-number-3">8.1.</span> Basic Operators</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Basic operators allow you to manipulate values.
</p>

<p>
<b>Concatenation</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">     <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">foo</span> = <span style="color: #98be65;">'hello'</span>;

     <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">bar</span> = <span style="color: #98be65;">'world'</span>;

     console.log(foo + <span style="color: #98be65;">' '</span> + bar); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">'hello world'</span>
</pre>
</div>

<p>
<b>Multiplication and division</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">     <span style="color: #da8548; font-weight: bold;">2</span> * <span style="color: #da8548; font-weight: bold;">3</span>;
     <span style="color: #da8548; font-weight: bold;">2</span> / <span style="color: #da8548; font-weight: bold;">3</span>;
</pre>
</div>

<p>
<b>Incrementing and decrementing</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">     <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">1</span>;

     <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">j</span> = ++i;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">pre-increment:  j equals 2; i equals 2</span>
     <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">k</span> = i++;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">post-increment: k equals 2; i equals 3</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-orgf00a9b2" class="outline-3">
<h3 id="orgf00a9b2"><span class="section-number-3">8.2.</span> Operations on Numbers &amp; Strings and type coercion</h3>
<div class="outline-text-3" id="text-8-2">
<p>
In JavaScript, numbers and strings will occasionally behave in ways you
might not expect. This is because of <b>coercion</b>. Coercion is converting from one type to another.
Because JavaScript is dynamically typed, this is often done silently.
</p>

<p>
<b>Addition vs. concatenation</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">foo</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">bar</span> = <span style="color: #98be65;">'2'</span>;

    console.log(foo + bar);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">12. uh oh,</span>
                             <span style="color: #5B6268;">// </span><span style="color: #5B6268;">coerced the 1 into '1' and do concatenation</span>
</pre>
</div>

<p>
<b>Forcing a string to act as a number</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">foo</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">bar</span> = <span style="color: #98be65;">'2'</span>;

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">coerce the string to a number</span>
    console.log(foo + Number(bar));
</pre>
</div>

<p>
The Number constructor, when called as a function (like above) will have
the effect of casting its argument into a number. You could also use the
unary plus operator, which does the same thing:
</p>

<p>
<b>Forcing a string to act as a number (using the unary-plus operator)</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    console.log(foo + +bar);
</pre>
</div>

<p>
If you do not want to use coercion, use the <b>strict</b> operators ( <code>=</code>, !== ).
It is recomended to use them always
</p>
</div>
</div>

<div id="outline-container-orgdfa8d30" class="outline-3">
<h3 id="orgdfa8d30"><span class="section-number-3">8.3.</span> Logical Operators</h3>
<div class="outline-text-3" id="text-8-3">
<p>
Logical operators allow you to evaluate a series of operands using AND
and OR operations.
</p>

<p>
<b>Logical AND and OR operators</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">foo</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">bar</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">baz</span> = <span style="color: #da8548; font-weight: bold;">2</span>;

    foo || bar;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 1, which is true</span>
    bar || foo;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 1, which is true</span>

    foo &amp;&amp; bar;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 0, which is false</span>
    foo &amp;&amp; baz;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 2, which is true</span>
    baz &amp;&amp; foo;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 1, which is true</span>
</pre>
</div>

<p>
Though it may not be clear from the example, the <code>||</code> operator returns
the value of the first truthy operand, or, in cases where neither
operand is truthy, it&rsquo;ll return the last of both operands.
This operator can be used for setting default values of undefined/null variables
</p>

<p>
The <code>&amp;&amp;</code> operator returns the value of the first false operand, or the value of
the last operand if both operands are truthy. This is called the <code>guard</code> operator,
and can be used for checking if the variable is set to a value.
</p>

<p>
Be sure to consult the section called <b>Truthy and falsey things</b> for more details on which values evaluate to
<code>true</code> and which evaluate to <code>false</code>.
</p>
</div>
</div>



<div id="outline-container-org1af48bf" class="outline-3">
<h3 id="org1af48bf"><span class="section-number-3">8.4.</span> Note</h3>
<div class="outline-text-3" id="text-8-4">
<p>
You&rsquo;ll sometimes see developers use these logical operators for flow
control instead of using <code>if</code> statements. For example:
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">do something with foo if foo is truthy</span>
    foo &amp;&amp; doSomething(foo);

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">set bar to baz if baz is truthy;</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">otherwise, set it to the return</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">value of createBar()</span>
    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">bar</span> = baz || createBar();
</pre>
</div>

<p>
This style is quite elegant and pleasantly terse; that said, it can be
really hard to read, especially for beginners. I bring it up here so
you&rsquo;ll recognize it in code you read, but I don&rsquo;t recommend using it
until you&rsquo;re extremely comfortable with what it means and how you can
expect it to behave.
</p>
</div>
</div>

<div id="outline-container-org6e5416b" class="outline-3">
<h3 id="org6e5416b"><span class="section-number-3">8.5.</span> Comparison Operators</h3>
<div class="outline-text-3" id="text-8-5">
<p>
Comparison operators allow you to test whether values are equivalent or
whether values are identical.
</p>

<p>
<b>Comparison operators</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">foo</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">bar</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">baz</span> = <span style="color: #98be65;">'1'</span>;
    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">bim</span> = <span style="color: #da8548; font-weight: bold;">2</span>;

    foo == bar;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns false</span>
    foo != bar;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns true</span>
    foo == baz;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns true; careful!</span>

    foo === baz;             <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns false</span>
    foo !== baz;             <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns true</span>
    foo === parseInt(baz);   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns true</span>

    foo &gt; bim;    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns false</span>
    bim &gt; baz;    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns true</span>
    foo &lt;= baz;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns true</span>

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Interesting pitfalls...</span>

    <span style="color: #da8548; font-weight: bold;">1</span> &lt; <span style="color: #da8548; font-weight: bold;">2</span> &lt; <span style="color: #da8548; font-weight: bold;">3</span>     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns true</span>
    <span style="color: #da8548; font-weight: bold;">3</span> &lt; <span style="color: #da8548; font-weight: bold;">2</span> &lt; <span style="color: #da8548; font-weight: bold;">1</span>;    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns true, false coerces to 0</span>

    <span style="color: #a9a1e1;">null</span> &lt; <span style="color: #da8548; font-weight: bold;">1</span>      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns true, null coerces to 0</span>
    <span style="color: #a9a1e1;">null</span> == <span style="color: #da8548; font-weight: bold;">0</span>     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns false ??</span>
    <span style="color: #a9a1e1;">undefined</span> &gt; <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns false</span>
    <span style="color: #a9a1e1;">undefined</span> &lt; <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns false</span>
    <span style="color: #98be65;">""</span> == <span style="color: #da8548; font-weight: bold;">0</span>       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">true</span>
    <span style="color: #98be65;">""</span> == <span style="color: #a9a1e1;">false</span>   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">true</span>

</pre>
</div>
<p>
For a better explination, see the following links:
</p>
<ul class="org-ul">
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness</a></li>
<li><a href="https://dorey.github.io/JavaScript-Equality-Table/unified/">https://dorey.github.io/JavaScript-Equality-Table/unified/</a></li>
</ul>
</div>
</div>


<div id="outline-container-org661dadb" class="outline-3">
<h3 id="org661dadb"><span class="section-number-3">8.6.</span> Operator precedence and associativity:</h3>
<div class="outline-text-3" id="text-8-6">
<p>
The list of operator precedence and associativity is given on the following link:
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">Operator Precedence and associativity</a>
</p>
</div>
</div>
</div>


<div id="outline-container-org0512b4c" class="outline-2">
<h2 id="org0512b4c"><span class="section-number-2">9.</span> Arrays</h2>
<div class="outline-text-2" id="text-9">
<p>
Arrays are zero-indexed lists of values. They are a handy way to store a
set of related items of the same type (such as strings), though in
reality, an array can include multiple types of items, including other
arrays.
</p>

<p>
Arrays in JavaScript are actually a special type of object. They work very much like regular objects
(numerical properties can naturally be accessed only using [] syntax) but they have one magic property called &rsquo;length&rsquo;.
This is always one more than the highest index in the array.
</p>

<p>
<b>A simple array</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myArray</span> = [ <span style="color: #98be65;">'hello'</span>, <span style="color: #98be65;">'world'</span> ];
</pre>
</div>

<p>
<b>Accessing array items by index</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myArray</span> = [ <span style="color: #98be65;">'hello'</span>, <span style="color: #98be65;">'world'</span>, <span style="color: #98be65;">'foo'</span>, <span style="color: #98be65;">'bar'</span> ];
    console.log(myArray[<span style="color: #da8548; font-weight: bold;">3</span>]);   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 'bar'</span>
</pre>
</div>

<p>
<b>Testing the size of an array</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myArray</span> = [ <span style="color: #98be65;">'hello'</span>, <span style="color: #98be65;">'world'</span> ];
    console.log(myArray.length);   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 2</span>
</pre>
</div>

<p>
<b>Changing the value of an array item</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myArray</span> = [ <span style="color: #98be65;">'hello'</span>, <span style="color: #98be65;">'world'</span> ];
    myArray[<span style="color: #da8548; font-weight: bold;">1</span>] = <span style="color: #98be65;">'changed'</span>;
</pre>
</div>

<p>
<i>While it&rsquo;s possible to change the value of an array item as shown in
“Changing the value of an array item”, it&rsquo;s generally not advised.</i>
</p>

<p>
<b>Adding elements to an array</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myArray</span> = [ <span style="color: #98be65;">'hello'</span>, <span style="color: #98be65;">'world'</span> ];
    myArray.push(<span style="color: #98be65;">'new'</span>);
</pre>
</div>

<p>
<b>Working with arrays</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myArray</span> = [ <span style="color: #98be65;">'h'</span>, <span style="color: #98be65;">'e'</span>, <span style="color: #98be65;">'l'</span>, <span style="color: #98be65;">'l'</span>, <span style="color: #98be65;">'o'</span> ];
    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myString</span> = myArray.join(<span style="color: #98be65;">''</span>);   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">'hello'</span>
    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">mySplit</span> = myString.split(<span style="color: #98be65;">''</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">[ 'h', 'e', 'l', 'l', 'o' ]</span>
</pre>
</div>

<p>
Note that <code>array.length</code> isn&rsquo;t necessarily the number of items in the
array. Consider the following:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">var</span> <span style="color: #dcaeea;">a</span> = [<span style="color: #98be65;">"dog"</span>, <span style="color: #98be65;">"cat"</span>, <span style="color: #98be65;">"hen"</span>];
a[<span style="color: #da8548; font-weight: bold;">100</span>] = <span style="color: #98be65;">"fox"</span>;

console.log(a.length)

<span style="color: #da8548; font-weight: bold;">101</span>
</pre>
</div>

<p>
If you query a non-existent array index, you get <code>undefined</code>:
</p>

<div class="org-src-container">
<pre class="src src-javascript">&gt; <span style="color: #51afef;">typeof</span> a[<span style="color: #da8548; font-weight: bold;">90</span>]

<span style="color: #a9a1e1;">undefined</span>
</pre>
</div>

<p>
If you take the above into account, you can iterate over an array using
the following:
</p>


<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; a.length; i++) {

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Do something with a[i]</span>

}
</pre>
</div>


<p>
This is slightly inefficient as you are looking up the length property
once every loop. An improvement is this:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">len</span> = a.length; i &lt; len; i++) {

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Do something with a[i]</span>

}
</pre>
</div>

<p>
An even nicer idiom is:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">item</span>; item = a[i++];) {

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Do something with item</span>

}
</pre>
</div>

<p>
Here we are setting up two variables. The assignment in the middle part
of the <code>for</code> loop is also tested for truthfulness - if it succeeds, the
loop continues. Since <code>i</code> is incremented each time, items from the array
will be assigned to item in sequential order. The loop stops when a
&ldquo;falsy&rdquo; item is found (such as <code>undefined</code>).
</p>

<p>
Note that this trick should only be used for arrays which you know do
not contain &ldquo;falsy&rdquo; values (arrays of objects
or <a href="https://developer.mozilla.org/en/DOM"><i>DOM</i></a> nodes for example).
If you are iterating over numeric data that might include a 0 or string
data that might include the empty string you should use the <code>i, len</code> idiom
instead.
</p>

<p>
Another way to iterate is to use
the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in"><i>for&#x2026;in</i></a> loop.
Note that if someone added new properties to Array.prototype, they will
also be iterated over by this loop:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span> <span style="color: #51afef;">in</span> a) {

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Do something with a[i]</span>

}
</pre>
</div>

<p>
If you want to append an item to an array simply do it like this:
</p>

<p>
a.push(item);
</p>

<p>
Arrays come with a number of methods:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><b>Method name</b></th>
<th scope="col" class="org-left"><b>Description</b></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a.toString()</td>
<td class="org-left">Returns a string with the toString() of</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">each element separated by commas.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">a.toLocaleString()</td>
<td class="org-left">Returns a string with the toLocaleString()</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">of each element separated by commas.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">a.concat(item[, itemN])</td>
<td class="org-left">Returns a new array with the items added on to it.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">a.join(sep)</td>
<td class="org-left">Converts the array to a string - values</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">delimited by the sep param</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">a.pop()</td>
<td class="org-left">Removes and returns the last item.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">a.push(item[, itemN])</td>
<td class="org-left">Push adds one or more items to the end.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">a.reverse()</td>
<td class="org-left">Reverse the array.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">a.shift()</td>
<td class="org-left">Removes and returns the first item.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">a.slice(start, end)</td>
<td class="org-left">Returns a sub-array.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">a.sort([cmpfn])</td>
<td class="org-left">Takes an optional comparison function.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">a.splice(start, delcount[, itemN])</td>
<td class="org-left">Lets you modify an array by deleting a</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">section and replacing it with more items.</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">a.unshift([item])</td>
<td class="org-left">Prepends items to the start of the array.</td>
</tr>
</tbody>
</table>

<p>
More methods can be found here: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array</a>
</p>
</div>
</div>
<div id="outline-container-orga30daac" class="outline-2">
<h2 id="orga30daac"><span class="section-number-2">10.</span> Important concepts</h2>
<div class="outline-text-2" id="text-10">
<p>
JavaScript comes with its own advantages and caveats.
To better understand the way JS works, some important concepts will be discussed!
</p>
</div>
<div id="outline-container-orgcc8ea84" class="outline-3">
<h3 id="orgcc8ea84"><span class="section-number-3">10.1.</span> Syntax Parser (SP)</h3>
<div class="outline-text-3" id="text-10-1">
<p>
The syntax parses is a program that reads your code and determines what it
does and if its grammar (syntax) is valid. Usually is part of a compiler or interpreter.
The compilers and interpreters are responsible for syntax parsing and
<b>translating</b> the code into executable commands (computer instructions).
</p>

<p>
The compilers/interprets <b><i>can add</i></b> additional commands as process of
optimizing the executable commands.
</p>


<div id="orgf0c140a" class="figure">
<p><img src="file:///tmp/babel-VG0msz/plantuml-hCYFCk.png" alt="plantuml-hCYFCk.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org5165061" class="outline-3">
<h3 id="org5165061"><span class="section-number-3">10.2.</span> Execution Context (EC)</h3>
<div class="outline-text-3" id="text-10-2">
<p>
An execution context is an <i>abstract concept</i> of an environment where the Javascript code is evaluated and executed.
Whenever any code is run in JavaScript, it’s run inside an execution context.
</p>

<p>
There are 3 types of Execution Contexts in JavaScript.
</p>

<dl class="org-dl">
<dt>Global Execution Context</dt><dd>This is the default or base execution context. The code that is not inside any function is in the global execution context.
It performs two things: it creates a global object which is a window object (in the case of browsers)
and sets the value of this to equal to the global object. There can only be one global execution context in a program.</dd>
<dt>Functional Execution Context</dt><dd>Every time a function is invoked, a brand new execution context is created for that function.
Each function has its own execution context, but it’s created when the function is invoked or called.
There can be any number of function execution contexts. Whenever a new execution context is created,
it goes through a series of steps in a defined order.</dd>
<dt>Eval Function Execution Context</dt><dd>Code executed inside an eval function also gets its own execution context,
but as eval isn’t (and shouldn&rsquo;t be) usually used by JavaScript developer except in special circumstances.</dd>
</dl>

<p>
In short, EC is a wrapper that help manage the code that is running.
The execution context is responsible for managing the code that is currently
running. Execution context can have code that sits in the different lexical
environments or other values.
</p>

<p>
Every script/code starts with an execution context called <i>global execution context</i>.
And every time <span class="underline">we call a function</span>, a new execution context <i>is created</i> and is put on top of the <i>execution stack</i>.
The same pattern follows when you call the nested function which calls another nested function:
</p>
</div>
</div>

<div id="outline-container-orgc19819f" class="outline-3">
<h3 id="orgc19819f"><span class="section-number-3">10.3.</span> Execution Stack (ES)</h3>
<div class="outline-text-3" id="text-10-3">
<p>
Execution stack, also known as “calling stack” in other programming languages,
is a stack with a <i>LIFO (Last in, First out)</i> structure, which is used to store all the
execution context created during the code execution.
</p>

<p>
When the JavaScript engine first encounters your script, it creates a <i>global execution context</i>
and pushes it to the current execution stack. Whenever the engine finds a function invocation,
it creates a new execution context for that function and pushes it to the top of the stack.
</p>

<p>
The engine executes the function whose execution context is at the top of the stack.
When this function completes, its execution stack is popped off from the stack,
and the control reaches to the context below it in the current stack.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Execution stack example</label><pre class="src src-javascript" id="org130cb2c"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">a</span> = <span style="color: #98be65;">'Hello World!'</span>;
<span style="color: #51afef;">function</span> <span style="color: #c678dd;">first</span>() {
  console.log(<span style="color: #98be65;">'Inside first function'</span>);
  second();
  console.log(<span style="color: #98be65;">'Again inside first function'</span>);
}
<span style="color: #51afef;">function</span> <span style="color: #c678dd;">second</span>() {
  console.log(<span style="color: #98be65;">'Inside second function'</span>);
}
first();
console.log(<span style="color: #98be65;">'Inside Global Execution Context'</span>);
</pre>
</div>


<div id="org0a5ba1b" class="figure">
<p><img src="img/execution-stack_example.png" alt="execution-stack_example.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Execution Stack of code segment</p>
</div>
</div>
</div>

<div id="outline-container-org04c4b94" class="outline-3">
<h3 id="org04c4b94"><span class="section-number-3">10.4.</span> Lexical Environment</h3>
<div class="outline-text-3" id="text-10-4">
<p>
According to ECMAScript specification 262 (8.1):
</p>

<blockquote>
<p>
A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code
</p>
</blockquote>

<p>
In JavaScript, <b>lexical environment</b> is a <i>data structure</i> that holds <i>identifier-variable mapping</i>. Where identifier refers to the name of variables/functions, and the variable is the reference to actual object [including function object or primitive value].
</p>

<p>
Lexical in general means in hierarchy or in a sequence. Whenever a new execution context (EC) is created a new lexical environment  is created and it is referenced in local EC in memory space.
</p>

<p class="verse">
Lexical Environment: Local Memory + Lexical Environment of its Parent<br />
</p>

<p>
Each Lexical Environment has three components:
</p>
<ul class="org-ul">
<li>Environment Record</li>
<li>Reference to the outer environment,</li>
<li>This binding.</li>
</ul>
</div>

<div id="outline-container-orge85a96b" class="outline-4">
<h4 id="orge85a96b"><span class="section-number-4">10.4.1.</span> Environment Record</h4>
<div class="outline-text-4" id="text-10-4-1">
<p>
The environment record is the place where the variable and function declarations are stored inside the lexical environment.
</p>

<p>
There are also two types of environment record:
</p>
<dl class="org-dl">
<dt>Declarative environment record</dt><dd>As its name suggests stores variable and function declarations. The lexical environment for function code contains a declarative environment record.</dd>
<dt>Object environment record</dt><dd>The lexical environment for global code contains a objective environment record. Apart from variable and function declarations, the object environment record also stores a global binding object (window object in browsers). So for each of binding object’s property (in case of browsers, it contains properties and methods provided by browser to the window object), a new entry is created in the record.</dd>
</dl>

<p>
For the function code, the environment record also contains an <i>arguments</i> object that contains the mapping between indexes and arguments passed to the function and the length(number) of the arguments passed into the function. For example, an argument object for the below function looks like this:
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #51afef;">function</span> <span style="color: #c678dd;">foo</span>(<span style="color: #dcaeea;">a</span>, <span style="color: #dcaeea;">b</span>) {
  <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">c</span> = a + b;
}
foo(<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>);

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">argument object</span>
Arguments: {<span style="color: #da8548; font-weight: bold;">0</span>: <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">1</span>: <span style="color: #da8548; font-weight: bold;">3</span>, length: <span style="color: #da8548; font-weight: bold;">2</span>},

</pre>
</div>
</div>
</div>
<div id="outline-container-org587c50d" class="outline-4">
<h4 id="org587c50d"><span class="section-number-4">10.4.2.</span> Reference to the Outer Environment</h4>
<div class="outline-text-4" id="text-10-4-2">
<p>
The reference to the outer environment means it has access to its outer lexical environment. That means that the JavaScript engine can look for variables inside the outer environment if they are not found in the current lexical environment.
</p>
</div>
</div>

<div id="outline-container-org0b7f243" class="outline-4">
<h4 id="org0b7f243"><span class="section-number-4">10.4.3.</span> This Binding</h4>
<div class="outline-text-4" id="text-10-4-3">
<p>
In this component, the value of <code>this</code> is determined or set.
In the global execution context, the value of this refers to the global object. (in browsers, this refers to the Window Object).
</p>

<p>
In the function execution context, the value of this depends on how the function is called. If it is called by an object reference, then the value of this is set to that object, otherwise, the value of this is set to the global object or undefined (in strict mode). For example:
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #51afef;">const</span> <span style="color: #dcaeea;">person</span> = {
  name: <span style="color: #98be65;">'peter'</span>,
  birthYear: <span style="color: #da8548; font-weight: bold;">1994</span>,
  <span style="color: #c678dd;">calcAge</span>: <span style="color: #51afef;">function</span>() {
    console.log(<span style="color: #da8548; font-weight: bold;">2018</span> - <span style="color: #a9a1e1;">this</span>.birthYear);
  }
}
person.calcAge();
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">'this' refers to 'person', because 'calcAge' was called with //'person' object reference</span>
<span style="color: #51afef;">const</span> <span style="color: #dcaeea;">calculateAge</span> = person.calcAge;
calculateAge();
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">'this' refers to the global window object, because no object reference was given</span>
</pre>
</div>

<p>
Abstractly, the lexical environment looks like this in pseudocode:
</p>
<pre class="example" id="org2d2557b">
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
    }
    outer: &lt;null&gt;,
    this: &lt;global object&gt;
  }
}
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
    }
    outer: &lt;Global or outer function environment reference&gt;,
    this: &lt;depends on how function is called&gt;
  }
}

</pre>
<p>
Variable Environment:
It’s also a Lexical Environment whose EnvironmentRecord holds bindings created by VariableStatements within this execution context.
</p>

<p>
As written above, the variable environment is also a lexical environment, So it has all the properties and components of a lexical environment as defined above.
</p>

<p>
In ES6, one difference between LexicalEnvironment component and the VariableEnvironment component is that the former is used to store function declaration and variable (let and const) bindings, while the latter is used to store the variable (var) bindings only.
</p>



<p>
So in short, a lexical environment is a place where variables and functions live or physically present during the program execution.
A lexical environment exists in programming languages in which where you write something is <code>important</code>.
</p>

<p>
Not all programming languages have correct lexical environment. The compiler/interpeter <b>cares where you put your stuff</b>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc8ee34f" class="outline-3">
<h3 id="orgc8ee34f"><span class="section-number-3">10.5.</span> Name-Value Pair and Objects</h3>
<div class="outline-text-3" id="text-10-5">
<p>
Name-Value pair represents a name that maps to a unique value. The name may
be defined more than once, but it can only have <b>one value in any given
execution context</b>.
The value can be more name/value pairs.
</p>
<div class="org-src-container">
<pre class="src src-javascript">address = <span style="color: #98be65;">'100th Main St.'</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">foo - name, 'hello world' - its value</span>
</pre>
</div>
<p>
In JavaScript, an object is a <b>collection of name-value pairs</b>.
</p>
<div class="org-src-container">
<pre class="src src-js">address: {
  street: <span style="color: #98be65;">'Main'</span>,
  number: <span style="color: #da8548; font-weight: bold;">100</span>,
  apartment: {
    floor: <span style="color: #da8548; font-weight: bold;">3</span>,
    number: <span style="color: #da8548; font-weight: bold;">301</span>
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1c6af84" class="outline-3">
<h3 id="org1c6af84"><span class="section-number-3">10.6.</span> Global Environment and The Global Object</h3>
<div class="outline-text-3" id="text-10-6">
<p>
In JS, code is run inside an execution context. The base execution context is
the <b>global</b> execution context.
Global means that is accessible anywhere, everywhere!!! The global execution
context implicitly creates the <b>Global Object</b> and a special variable <b>this</b>.
</p>

<p>
In browsers, the <code>window</code> object is the global object. If we are in the
global execution context, the <code>this</code> variable references the global object.
</p>


<div id="org315b323" class="figure">
<p><img src="img/global-execution-context.png" alt="global-execution-context.png" />
</p>
<p><span class="figure-number">Figure 2: </span>The Global Execution Context and Global Object</p>
</div>

<p>
In short, everything that is not inside a function is part of the global object.
The execution context also contains a reference to the outer environment.
If no outer environment is present (a.k.a we are in the global execution
context, the value is <code>null</code>)
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #51afef;">var</span> <span style="color: #dcaeea;">a</span> = <span style="color: #98be65;">'Hello World!'</span>;

<span style="color: #51afef;">function</span> <span style="color: #c678dd;">b</span>() {
  <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">c</span> = <span style="color: #98be65;">"Hello Function"</span>;
}

console.log(a);
console.log(b);
console.log(c);
</pre>
</div>

<p class="verse">
OUTPUT:<br />
Hello World<br />
Hello Function<br />
// Error: &#x2026;<br />
</p>


<div id="org0395c83" class="figure">
<p><img src="img/execution-context-diagram.png" alt="execution-context-diagram.png" />
</p>
<p><span class="figure-number">Figure 3: </span>The execution context for the previous code</p>
</div>
</div>
</div>

<div id="outline-container-org1364f59" class="outline-3">
<h3 id="org1364f59"><span class="section-number-3">10.7.</span> Hoisting and creating execution context</h3>
<div class="outline-text-3" id="text-10-7">
<p>
Consider the following example
</p>

<div class="org-src-container">
<pre class="src src-js">b();
console.log(a);

<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">a</span> = <span style="color: #98be65;">'Hello World!'</span>;

<span style="color: #51afef;">function</span> <span style="color: #c678dd;">b</span>() {
  console.log(<span style="color: #98be65;">'Called b!'</span>);
}
</pre>
</div>

<p>
In other languages like C, We can presume that this code is invalid because
the function <code>b</code> is called before its declaration.
Also we can say that the variable <code>a</code> is accessed before it is declared,
thus creating an error.
</p>

<p>
Instead the output is:
</p>
<div class="org-src-container">
<pre class="src src-javascript">Called b!
<span style="color: #a9a1e1;">undefined</span>
</pre>
</div>

<p>
This is because of an procedure called <b>hoisting</b>. The hoisting is a direct
cause of creating execution contexts.
</p>

<p>
When execution context is created, the JavaScript engine passes 2 phases.
</p>
</div>


<div id="outline-container-org31216dd" class="outline-4">
<h4 id="org31216dd"><span class="section-number-4">10.7.1.</span> Creation phase</h4>
<div class="outline-text-4" id="text-10-7-1">
<p>
The execution context is created during the creation phase. Following things happen during the creation phase:
</p>
<ul class="org-ul">
<li>LexicalEnvironment component is created.</li>
<li>VariableEnvironment component is created.</li>
</ul>

<p>
So the execution context can be conceptually represented as follows:
</p>

<pre class="example" id="org2a770e8">
ExecutionContext = {
  LexicalEnvironment = &lt;ref. to LexicalEnvironment in memory&gt;,
  VariableEnvironment = &lt;ref. to VariableEnvironment in  memory&gt;,
}
</pre>

<p>
The global object is set up, <code>this</code> is also set up and the outer environment is also set.
The parser also goes trough the source   code and setups memory space for variable and function.
</p>

<p>
This means that before the code is executed, the JS engine creates the functions and variables.
The variables in this phase are set to the <code>undefined</code> value, and the code of the functions is <b>placed in memory</b>.
</p>
</div>
</div>

<div id="outline-container-org470e192" class="outline-4">
<h4 id="org470e192"><span class="section-number-4">10.7.2.</span> Execution phase</h4>
<div class="outline-text-4" id="text-10-7-2">
<p>
the code is interpeted and the commands are executed, line by line.
</p>


<p>
<b>This means that every javascript engine passes the code twice, once for the
creation phase, the second time for the execution phase.</b>
</p>
</div>
</div>
</div>



<div id="outline-container-orga96cdeb" class="outline-3">
<h3 id="orga96cdeb"><span class="section-number-3">10.8.</span> Execution Stack, Function Invocation and Variable environment</h3>
<div class="outline-text-3" id="text-10-8">
<p>
Every function invocation creates a new execution context. Each context is
placed in the execution stack and processed accordingly.
When finished, the execution context is popped off the execution stack.
</p>

<p>
For example, the following code creates the execution stack given in the picture.
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">function</span> <span style="color: #c678dd;">b</span>(){
}

<span style="color: #51afef;">function</span> <span style="color: #c678dd;">a</span>(){
  b();
}

a();
</pre>
</div>


<div id="org2e5a1b1" class="figure">
<p><img src="img/execution-stack.png" alt="execution-stack.png" />
</p>
<p><span class="figure-number">Figure 4: </span>The Execution Stack</p>
</div>

<p>
Every execution context has its own variable environment (memory space).
</p>

<p>
Consider the following code:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">function</span> <span style="color: #c678dd;">b</span>() {
  <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myVar</span>;
  console.log(myVar);
}

<span style="color: #51afef;">function</span> <span style="color: #c678dd;">a</span>() {
  <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #da8548; font-weight: bold;">2</span>;
  console.log(myVar);
  b();
}

<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
console.log(myVar);
a();
console.log(myVar);
</pre>
</div>

<p>
The output is:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #da8548; font-weight: bold;">1</span>
<span style="color: #da8548; font-weight: bold;">2</span>
<span style="color: #a9a1e1;">undefined</span>
<span style="color: #da8548; font-weight: bold;">1</span>
</pre>
</div>


<div id="org0171dcc" class="figure">
<p><img src="img/variable-env.png" alt="variable-env.png" />
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org9417efd" class="outline-2">
<h2 id="org9417efd"><span class="section-number-2">11.</span> Scope and the scope chain</h2>
<div class="outline-text-2" id="text-11">
<p>
&ldquo;Scope&rdquo; refers to the variables that are available to a piece of code at
a given time. A lack of understanding of scope can lead to frustrating
debugging experiences.
</p>

<p>
When a variable is declared inside of a function using the <code>var</code>
keyword, it is only available to code inside of that function &#x2014; code
outside of that function cannot access the variable. On the other hand,
functions defined <i>inside</i> that function <i>will</i> have access to to the
declared variable.
</p>

<p>
Furthermore, variables that are declared inside a function without the
<code>var</code> keyword are not local to the function &#x2014; JavaScript will traverse
the scope chain all the way up to the window scope to find where the
variable was previously defined. If the variable wasn&rsquo;t previously
defined, it will be defined in the global scope, which can have
extremely unexpected consequences.
</p>


<p>
Consider the folowing example:
</p>
<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">function</span> <span style="color: #c678dd;">b</span>() {
     console.log(myVar);
   }

   <span style="color: #51afef;">function</span> <span style="color: #c678dd;">a</span>() {
     <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #da8548; font-weight: bold;">2</span>;
     console.log(myVar);
     b();
   }

   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
   a();
</pre>
</div>
<p>
The output is:
</p>
<div class="org-src-container">
<pre class="src src-javascript">  <span style="color: #da8548; font-weight: bold;">1</span>
</pre>
</div>
<p>
The output is <i>1</i> because the <code>function b</code> has the outer environment is set to the global environment.
This is because of the lexical environment.
The function determines its outer environment based on the lexical environment.
In our example functions <code>a</code> and <code>b</code> sits lexically in the global environment.
<img src="img/scope-execution-context.png" alt="scope-execution-context.png" />
</p>

<p>
This means that the execution stack does not have to be the same as the scope chain!
</p>

<p>
If we change the previous example as following:
</p>
<div class="org-src-container">
<pre class="src src-javascript">
   <span style="color: #51afef;">function</span> <span style="color: #c678dd;">a</span>() {

     <span style="color: #51afef;">function</span> <span style="color: #c678dd;">b</span>() {
       console.log(myVar);
     }

     <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #da8548; font-weight: bold;">2</span>;
     console.log(myVar);
     b();
   }

   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
   a();
   b();
</pre>
</div>

<p>
The output is:
</p>
<div class="org-src-container">
<pre class="src src-javascript">  <span style="color: #da8548; font-weight: bold;">2</span>
</pre>
</div>


<p>
Here we change the lexical environment of <code>function b</code>, hence the scope chain has changed to the following.
</p>


<div id="org14a93c9" class="figure">
<p><img src="img/scope-lexical-environment.png" alt="scope-lexical-environment.png" />
</p>
</div>

<p>
Also note that the <code>function b</code> is not accessible in the global execution context, thus the last line <code>b();</code> reports a Reference Error.
</p>

<p>
Think about what will happen if the line <code>var myVar = 2</code> was removed from the function a.
</p>
</div>

<div id="outline-container-org70f0aa0" class="outline-3">
<h3 id="org70f0aa0"><span class="section-number-3">11.1.</span> Variable declaration: var, const, let</h3>
<div class="outline-text-3" id="text-11-1">
<p>
In JavaScript, there are three keywords available to declare a variable, and each has its differences. Those are <code>var</code>, <code>let</code> and <code>const</code>.
</p>
</div>

<div id="outline-container-orgba6eda2" class="outline-4">
<h4 id="orgba6eda2"><span class="section-number-4">11.1.1.</span> Short explanation</h4>
<div class="outline-text-4" id="text-11-1-1">
<p>
Variables declared with <code>const</code> keyword can&rsquo;t be reassigned, while <code>let</code> and <code>var</code> can.
</p>

<p>
Always declare your variables with <code>const</code> by default, and with <code>let</code> if you need to <i>mutate</i> it or reassign it later.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Scope</th>
<th scope="col" class="org-left">Reassignable</th>
<th scope="col" class="org-left">Mutable</th>
<th scope="col" class="org-left">Temporal Dead Zone</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">const</td>
<td class="org-left">block</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">let</td>
<td class="org-left">block</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">var</td>
<td class="org-left">function</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">const</span> <span style="color: #dcaeea;">person</span> = <span style="color: #98be65;">"Nick"</span>;
person = <span style="color: #98be65;">"John"</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Will raise an error, person can't be reassigned</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">person</span> = <span style="color: #98be65;">"Nick"</span>;
person = <span style="color: #98be65;">"John"</span>;
console.log(person) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"John", reassignment is allowed with let</span>
</pre>
</div>

<blockquote>
<p>
Remember, the scope of a variable roughly means <b>&ldquo;where is this variable available in the code&rdquo;</b>.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">function</span> <span style="color: #c678dd;">f</span>() {
    {
        <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">x</span>;
        {
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">okay, block scoped name</span>
            <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">x</span> = <span style="color: #98be65;">"sneaky"</span>;
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">error, const</span>
            x = <span style="color: #98be65;">"foo"</span>;
        }
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">error, already declared in block</span>
        <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">x</span> = <span style="color: #98be65;">"inner"</span>;
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org31577b0" class="outline-4">
<h4 id="org31577b0"><span class="section-number-4">11.1.2.</span> <code>var</code> keyword</h4>
<div class="outline-text-4" id="text-11-1-2">
<p>
<code>var</code> declared variables are <i>function scoped</i>, meaning that when a variable is created in a function, everything in that function can access that variable. Besides, a <i>function scoped</i> variable created in a function can&rsquo;t be accessed outside this function.
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">myFunction</span>() {
      <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #98be65;">"Nick"</span>;
      console.log(myVar); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"Nick" - myVar is accessible inside the function</span>
    }
    console.log(myVar); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Throws a ReferenceError, myVar is not accessible outside the function.</span>
</pre>
</div>

<p>
Still focusing on the variable scope, here is a more subtle example:
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">myFunction</span>() {
      <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #98be65;">"Nick"</span>;
      <span style="color: #51afef;">if</span> (<span style="color: #a9a1e1;">true</span>) {
        <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #98be65;">"John"</span>;
        console.log(myVar); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"John"</span>
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">actually, myVar being function scoped, we just erased the previous myVar value "Nick" for "John"</span>
      }
      console.log(myVar); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"John" - see how the instructions in the if block affected this value</span>
    }
    console.log(myVar); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Throws a ReferenceError, myVar is not accessible outside the function.</span>
</pre>
</div>

<p>
Besides, <i>var</i> declared variables are moved to the top of the scope at execution. This is what we called <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting">var hoisting</a>.
</p>

<p>
This portion of code:
</p>
<div class="org-src-container">
<pre class="src src-js">    console.log(myVar) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">undefined -- no error raised</span>
    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #da8548; font-weight: bold;">2</span>;
</pre>
</div>

<p>
is understood at execution like:
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myVar</span>;
    console.log(myVar) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">undefined -- no error raised</span>
    myVar = <span style="color: #da8548; font-weight: bold;">2</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaafc217" class="outline-4">
<h4 id="orgaafc217"><span class="section-number-4">11.1.3.</span> <code>let</code> keyword</h4>
<div class="outline-text-4" id="text-11-1-3">
<p>
<code>var</code> and <code>let</code> are about the same, but <code>let</code> declared variables
</p>
<ul class="org-ul">
<li>are <i>block scoped</i></li>
<li>are <b>not</b> accessible before they are assigned</li>
<li>can&rsquo;t be re-declared in the same scope</li>
</ul>

<p>
Let&rsquo;s see the impact of block-scoping taking our previous example:
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">myFunction</span>() {
      <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #98be65;">"Nick"</span>;
      <span style="color: #51afef;">if</span> (<span style="color: #a9a1e1;">true</span>) {
        <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #98be65;">"John"</span>;
        console.log(myVar); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"John"</span>
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">actually, myVar being block scoped, we just created a new variable myVar.</span>
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">this variable is not accessible outside this block and totally independent</span>
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">from the first myVar created !</span>
      }
      console.log(myVar); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"Nick", see how the instructions in the if block DID NOT affect this value</span>
    }
    console.log(myVar); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Throws a ReferenceError, myVar is not accessible outside the function.</span>
</pre>
</div>

<p>
Now, what it means for <i>let</i> (and <i>const</i>) variables for not being accessible before being assigned:
</p>

<div class="org-src-container">
<pre class="src src-js">    console.log(myVar) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">raises a ReferenceError !</span>
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #da8548; font-weight: bold;">2</span>;
</pre>
</div>

<p>
By contrast with <i>var</i> variables, if you try to read or write on a <i>let</i> or <i>const</i> variable before they are assigned an error will be raised. This phenomenon is often called <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone_and_errors_with_let"><i>Temporal dead zone</i></a> or <b><i>TDZ</i></b>.
</p>

<blockquote>
<p>
<b>Note:</b> Technically, <i>let</i> and <i>const</i> variables declarations are being hoisted too, but not their assignation. Since they&rsquo;re made so that they can&rsquo;t be used before assignation, it intuitively feels like there is no hoisting, but there is. Find out more on this <a href="http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified">very detailed explanation here</a> if you want to know more.
</p>
</blockquote>

<p>
In addition, you can&rsquo;t re-declare a <i>let</i> variable:
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #da8548; font-weight: bold;">2</span>;
    <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #da8548; font-weight: bold;">3</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Raises a SyntaxError</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org3cafce0" class="outline-4">
<h4 id="org3cafce0"><span class="section-number-4">11.1.4.</span> <code>const</code> keyword</h4>
<div class="outline-text-4" id="text-11-1-4">
<p>
<code>const</code> declared variables behave like <i>let</i> variables, but also they can&rsquo;t be reassigned.
To sum it up, <i>const</i> variables:
</p>
<ul class="org-ul">
<li>are <i>block scoped</i></li>
<li>are not accessible before being assigned</li>
<li>can&rsquo;t be re-declared in the same scope</li>
<li>can&rsquo;t be reassigned</li>
</ul>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #98be65;">"Nick"</span>;
    myVar = <span style="color: #98be65;">"John"</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">raises an error, reassignment is not allowed</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #98be65;">"Nick"</span>;
    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">myVar</span> = <span style="color: #98be65;">"John"</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">raises an error, re-declaration is not allowed</span>
</pre>
</div>

<p>
But there is a subtlety : <code>const</code> variables are not <b>immutable</b> ! Concretely, it means that <i>object</i> and <i>array</i> <code>const</code> declared variables <b>can</b> be mutated.
</p>

<p>
For objects:
</p>
<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">person</span> = {
      name: <span style="color: #98be65;">'Nick'</span>
    };
    person.name = <span style="color: #98be65;">'John'</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">this will work ! person variable is not completely reassigned, but mutated</span>
    console.log(person.name) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"John"</span>
    person = <span style="color: #98be65;">"Sandra"</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">raises an error, because reassignment is not allowed with const declared variables</span>
</pre>
</div>

<p>
For arrays:
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">person</span> = [];
    person.push(<span style="color: #98be65;">'John'</span>); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">this will work ! person variable is not completely reassigned, but mutated</span>
    console.log(person[<span style="color: #da8548; font-weight: bold;">0</span>]) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"John"</span>
    person = [<span style="color: #98be65;">"Nick"</span>] <span style="color: #5B6268;">// </span><span style="color: #5B6268;">raises an error, because reassignment is not allowed with const declared variables</span>
</pre>
</div>
</div>
</div>
</div>
</div>




<div id="outline-container-org8ecefb4" class="outline-2">
<h2 id="org8ecefb4"><span class="section-number-2">12.</span> Functions</h2>
<div class="outline-text-2" id="text-12">
<p>
Functions contain blocks of code that need to be executed repeatedly.
Functions can take zero or more arguments, and can optionally return a
value.
</p>

<p>
Functions are <b>First class citizens of the languages</b>.
This means that you can use them as any other type.
It is a special type of <code>object</code>, but it is an object!
You can assign custom properties of the functions.
</p>

<p>
The function object has special properties:
</p>
<dl class="org-dl">
<dt>name</dt><dd>can be undefined</dd>
<dt>code</dt><dd>the code of the function. This property is <code>invocable</code></dd>
</dl>

<p>
./img/function-object.png]]
</p>

<p>
Take the following example:
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">function</span> <span style="color: #c678dd;">greet</span>() {
  console.log(<span style="color: #98be65;">'hi'</span>);
}

greet.language = <span style="color: #98be65;">'english'</span>;
console.log(greet);
</pre>
</div>

<p>
./img/function-object-example.png]]
</p>
</div>


<div id="outline-container-org8afaaab" class="outline-3">
<h3 id="org8afaaab"><span class="section-number-3">12.1.</span> Function Statements vs function expressions</h3>
<div class="outline-text-3" id="text-12-1">
<p>
Functions can be created in a variety of ways:
</p>

<p>
<b>Function Statement</b>
</p>
<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">greet</span>() {
      console.log(<span style="color: #98be65;">'hi'</span>);
    }
</pre>
</div>

<p>
Function statement does not evaluate to a value.
</p>


<div id="orgbf20602" class="figure">
<p><img src="img/function-statement.png" alt="function-statement.png" />
</p>
</div>

<p>
<b>Named Function Expression</b>
</p>
<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">greet</span> = <span style="color: #51afef;">function</span> greeting() {
      console.log(<span style="color: #98be65;">'hi'</span>);
    }
</pre>
</div>
<p>
When using named functions, we create a variable that references to the function in memory.
</p>

<p>
We can simplify the <b>named function example</b> using the following code:
</p>
<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">greet</span> = <span style="color: #51afef;">function</span> () {
      console.log(<span style="color: #98be65;">'hi'</span>);
    }
</pre>
</div>
<p>
Because we reference the function using the greet variable, we can omit the name of the function.
The functions that don&rsquo;t have a name are called anonymous functions!
</p>


<div id="org096e63a" class="figure">
<p><img src="img/function-expression.png" alt="function-expression.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-javascript">  greet(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Will execute the function</span>

  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Function Statement</span>
  <span style="color: #51afef;">function</span> <span style="color: #c678dd;">greet</span>() {
    console.log(<span style="color: #98be65;">'hi'</span>);
  }

  anonymousGreet(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Uncaught TypeError</span>

  <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">anonymousGreet</span> = <span style="color: #51afef;">function</span>() {
    console.log(<span style="color: #98be65;">'hi'</span>);
  }

  anonymousGreet(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Will execute</span>

  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Executing function passed as parameter (callback)</span>
  <span style="color: #51afef;">function</span> <span style="color: #c678dd;">log</span>(<span style="color: #dcaeea;">a</span>) {
   a();
  }

  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">create a function on the fly</span>
  log(<span style="color: #51afef;">function</span>() {
    console.log(<span style="color: #98be65;">'hi'</span>);
  });
</pre>
</div>
</div>
</div>

<div id="outline-container-org92b0239" class="outline-3">
<h3 id="org92b0239"><span class="section-number-3">12.2.</span> References and values</h3>
<div class="outline-text-3" id="text-12-2">
<p>
In JavaScript, every primitive type is passed by value (copied).
Every non-primitive type is passed by referece.
</p>

<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">by value (primitives)</span>
   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">3</span>;
   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">b</span>;

   b = a;
   a = <span style="color: #da8548; font-weight: bold;">2</span>;

   console.log(a);
   console.log(b);

   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">by reference (all objects (including functions))</span>
   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">c</span> = { greeting: <span style="color: #98be65;">'hi'</span> };
   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">d</span>;

   d = c;
   c.greeting = <span style="color: #98be65;">'hello'</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">mutate</span>

   console.log(c);
   console.log(d);

   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">by reference (even as parameters)</span>
   <span style="color: #51afef;">function</span> <span style="color: #c678dd;">changeGreeting</span>(<span style="color: #dcaeea;">obj</span>) {
    obj.greeting = <span style="color: #98be65;">'Hola'</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">mutate</span>
   }

   changeGreeting(d);
   console.log(c);
   console.log(d);

   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">equals operator sets up new memory space (new address)</span>
   c = { greeting: <span style="color: #98be65;">'howdy'</span> };
   console.log(c);
   console.log(d);
</pre>
</div>

<p>
The output is:
</p>
<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #da8548; font-weight: bold;">2</span>
   <span style="color: #da8548; font-weight: bold;">3</span>
   Object { greeting: <span style="color: #98be65;">"hello"</span> }
   Object { greeting: <span style="color: #98be65;">"hello"</span> }
   Object { greeting: <span style="color: #98be65;">"Hola"</span> }
   Object { greeting: <span style="color: #98be65;">"Hola"</span> }
   Object { greeting: <span style="color: #98be65;">"howdy"</span> }
   Object { greeting: <span style="color: #98be65;">"Hola"</span> }
</pre>
</div>
</div>
</div>


<div id="outline-container-orgaa0330b" class="outline-3">
<h3 id="orgaa0330b"><span class="section-number-3">12.3.</span> The <code>this</code> keyword, objects and functions</h3>
<div class="outline-text-3" id="text-12-3">
<p>
When an execution context for a function is created, during the creation phase,
the variable environment, the outer environment and the this keyword are set.
</p>



<div id="org576b7d6" class="figure">
<p><img src="img/execution-contex-creating-this.png" alt="execution-contex-creating-this.png" />
</p>
</div>

<p>
The setting of the <code>this</code> keyword can be different for different situations.
For example:
</p>
<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">function</span> <span style="color: #c678dd;">a</span>() {
    console.log(<span style="color: #a9a1e1;">this</span>); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Global Object</span>
    <span style="color: #a9a1e1;">this</span>.newvariable = <span style="color: #98be65;">'hello'</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Add to the global object</span>
   }

   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">b</span> = <span style="color: #51afef;">function</span>() {
    console.log(<span style="color: #a9a1e1;">this</span>); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Global Object</span>
   }

   a();

   console.log(newvariable); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">not good!</span>

   b();

   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Using object literal</span>
   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">c</span> = {
    name: <span style="color: #98be65;">'The c object'</span>, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">object property</span>

   <span style="color: #c678dd;">log1</span>: <span style="color: #51afef;">function</span>() {
    console.log(<span style="color: #a9a1e1;">this</span>);
   },

   <span style="color: #c678dd;">update</span>: <span style="color: #51afef;">function</span>() {
    <span style="color: #a9a1e1;">this</span>.name = <span style="color: #98be65;">"Updated object"</span>;
   },

   <span style="color: #c678dd;">log2</span>: <span style="color: #51afef;">function</span>() {

     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">This will not behave correctly</span>

     <span style="color: #a9a1e1;">this</span>.name = <span style="color: #98be65;">'Updated in log2'</span>;
     console.log(<span style="color: #a9a1e1;">this</span>);

     <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">setname</span> = <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">newname</span>) {
       <span style="color: #a9a1e1;">this</span>.name = newname;
     }

     setname(<span style="color: #98be65;">"Updated in setname"</span>);

     console.log(<span style="color: #a9a1e1;">this</span>);
   },



   <span style="color: #c678dd;">log</span>: <span style="color: #51afef;">function</span>() {
     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Handling the log2 problem</span>

        <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">self</span> = <span style="color: #a9a1e1;">this</span>;

        self.name = <span style="color: #98be65;">'Updated c object'</span>;
        console.log(self);

        <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">setname</span> = <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">newname</span>) {
            self.name = newname;
        }
        setname(<span style="color: #98be65;">'Updated again! The c object'</span>);
        console.log(self);
    }
   }
   c.log1();
   c.log2();
   c.log();

</pre>
</div>

<p>
The value of <code>this</code> inside the log2 function is not behaving correctly.
Functions that are defined inside methods of an object do not set the this variable to the object.
To avoid that, we can use an additional variable (usually called <code>self</code> or <code>that</code>).
</p>


<p>
The value of <code>this</code> is determined using a simple series of steps:
</p>

<ol class="org-ol">
<li>If the function is invoked using <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call">Function.call</a> or <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply">Function.apply</a>, <code>this</code> will be set to the first argument passed to call/apply. If the first argument passed to call/apply is <code>null</code> or <code>undefined</code>, <code>this</code> will refer to the global object (which is the <code>window</code> object in Web browsers).</li>
<li>If the function being invoked was created using <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Function.bind</a>, <code>this</code> will be the first argument that was passed to bind at the time the function was created.</li>
<li>If the function is being invoked as a method of an object, <code>this</code> will refer to that object.</li>
<li>Otherwise, the function is being invoked as a standalone function not attached to any object, and <code>this</code> will refer to the global object.</li>
</ol>

<p>
<b>A function invoked using Function.call</b>
</p>
<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myObject</span> = {
        <span style="color: #c678dd;">sayHello</span> : <span style="color: #51afef;">function</span>() {
            console.log(<span style="color: #98be65;">'Hi! My name is '</span> + <span style="color: #a9a1e1;">this</span>.myName);
        },

        myName : <span style="color: #98be65;">'Rebecca'</span>
    };

    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">secondObject</span> = {
        myName : <span style="color: #98be65;">'Colin'</span>
    };

    myObject.sayHello();                  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 'Hi! My name is Rebecca'</span>
    myObject.sayHello.call(secondObject); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 'Hi! My name is Colin'</span>
</pre>
</div>

<p>
<b>A function created using Function.bind</b>
</p>
<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myName</span> = <span style="color: #98be65;">'the global object'</span>,

        sayHello = <span style="color: #51afef;">function</span> () {
            console.log(<span style="color: #98be65;">'Hi! My name is '</span> + <span style="color: #a9a1e1;">this</span>.myName);
        },

        myObject = {
            myName : <span style="color: #98be65;">'Rebecca'</span>
        };

    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myObjectHello</span> = sayHello.bind(myObject);

    sayHello();       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 'Hi! My name is the global object'</span>
    myObjectHello();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 'Hi! My name is Rebecca'</span>
</pre>
</div>

<p>
<b>A function being attached to an object at runtime</b>
</p>
<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myName</span> = <span style="color: #98be65;">'the global object'</span>,

        sayHello = <span style="color: #51afef;">function</span>() {
            console.log(<span style="color: #98be65;">'Hi! My name is '</span> + <span style="color: #a9a1e1;">this</span>.myName);
        },

        myObject = {
            myName : <span style="color: #98be65;">'Rebecca'</span>
        },

        secondObject = {
            myName : <span style="color: #98be65;">'Colin'</span>
        };

    myObject.sayHello = sayHello;
    secondObject.sayHello = sayHello;

    sayHello();               <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 'Hi! My name is the global object'</span>
    myObject.sayHello();      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 'Hi! My name is Rebecca'</span>
    secondObject.sayHello();  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 'Hi! My name is Colin'</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbb7869a" class="outline-3">
<h3 id="orgbb7869a"><span class="section-number-3">12.4.</span> Arguments and spread</h3>
<div class="outline-text-3" id="text-12-4">
<p>
An additional variable that is set for an execution context is the <code>arguments</code> keyword.
It contains all the parameters that are passed to the function.
</p>


<div id="org370b797" class="figure">
<p><img src="img/arguments-execution-context.png" alt="arguments-execution-context.png" />
</p>
</div>

<p>
Consider the following example
</p>
<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">function</span> <span style="color: #c678dd;">greet</span>(<span style="color: #dcaeea;">firstname</span>, <span style="color: #dcaeea;">lastname</span>, <span style="color: #dcaeea;">language</span>) {

    language = language || <span style="color: #98be65;">'en'</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">setting up default parameters</span>


   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Arguments is an array like object</span>
    <span style="color: #51afef;">if</span> (<span style="color: #a9a1e1;">arguments</span>.length === <span style="color: #da8548; font-weight: bold;">0</span>) {
        console.log(<span style="color: #98be65;">'Missing parameters!'</span>);
        console.log(<span style="color: #98be65;">'-------------'</span>);
        <span style="color: #51afef;">return</span>;
    }

    console.log(firstname);
    console.log(lastname);
    console.log(language);
    console.log(<span style="color: #a9a1e1;">arguments</span>);
    console.log(<span style="color: #98be65;">'arg 0: '</span> + <span style="color: #a9a1e1;">arguments</span>[<span style="color: #da8548; font-weight: bold;">0</span>]);
    console.log(<span style="color: #98be65;">'-------------'</span>);

   }

   greet();
   greet(<span style="color: #98be65;">'John'</span>);
   greet(<span style="color: #98be65;">'John'</span>, <span style="color: #98be65;">'Doe'</span>);
   greet(<span style="color: #98be65;">'John'</span>, <span style="color: #98be65;">'Doe'</span>, <span style="color: #98be65;">'es'</span>);

   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">in ES6 I can do:  function greet(firstname, ...other)</span>
   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">and 'other' will be an array that contains the rest of the arguments</span>

</pre>
</div>
</div>
</div>


<div id="outline-container-org955ebf5" class="outline-3">
<h3 id="org955ebf5"><span class="section-number-3">12.5.</span> Immediately invoked function expression and  Self-Executing Anonymous Functions</h3>
<div class="outline-text-3" id="text-12-5">
<p>
A common pattern in JavaScript is the self-executing anonymous function.
This pattern creates a function expression and then immediately executes
the function. This pattern is extremely useful for cases where you want
to avoid polluting the global namespace with your code &#x2014; no variables
declared inside of the function are visible outside of it.
</p>

<p>
<b>A self-executing anonymous function</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    (<span style="color: #51afef;">function</span>(){
        <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">foo</span> = <span style="color: #98be65;">'Hello world'</span>;
    })();


    console.log(foo);   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">undefined!</span>
</pre>
</div>

<p>
If we expand this to function expressions we get
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">function statement</span>
<span style="color: #51afef;">function</span> <span style="color: #c678dd;">greet</span>(<span style="color: #dcaeea;">name</span>) {
    console.log(<span style="color: #98be65;">'Hello '</span> + name);
}
greet(<span style="color: #98be65;">'John'</span>);

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">using a function expression</span>
<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">greetFunc</span> = <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">name</span>) {
    console.log(<span style="color: #98be65;">'Hello '</span> + name);
};
greetFunc(<span style="color: #98be65;">'John'</span>);

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">using an Immediately Invoked Function Expression (IIFE)</span>
<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">greeting</span> = <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">name</span>) {

    <span style="color: #51afef;">return</span> <span style="color: #98be65;">'Hello '</span> + name;

}(<span style="color: #98be65;">'John'</span>);

console.log(greeting);

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">IIFE</span>
<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">firstname</span> = <span style="color: #98be65;">'John'</span>;

(<span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">name</span>) {

    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">greeting</span> = <span style="color: #98be65;">'Inside IIFE: Hello'</span>;
    console.log(greeting + <span style="color: #98be65;">' '</span> + name);

}(firstname)); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">IIFE</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-org2e51a68" class="outline-3">
<h3 id="org2e51a68"><span class="section-number-3">12.6.</span> Functions as Arguments</h3>
<div class="outline-text-3" id="text-12-6">
<p>
In JavaScript, functions are &ldquo;first-class citizens&rdquo; &#x2014; they can be
assigned to variables or passed to other functions as arguments. Passing
functions as arguments is an extremely common idiom in jQuery.
</p>

<p>
<b>Passing an anonymous function as an argument</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myFn</span> = <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">fn</span>) {
        <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">result</span> = fn();
        console.log(result);
    };

    myFn(<span style="color: #51afef;">function</span>() { <span style="color: #51afef;">return</span> <span style="color: #98be65;">'hello world'</span>; });   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 'hello world'</span>
</pre>
</div>

<p>
<b>Passing a named function as an argument</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myFn</span> = <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">fn</span>) {
        <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">result</span> = fn();
        console.log(result);
    };

    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myOtherFn</span> = <span style="color: #51afef;">function</span>() {
        <span style="color: #51afef;">return</span> <span style="color: #98be65;">'hello world'</span>;
    };

    myFn(myOtherFn);   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 'hello world'</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org09c1971" class="outline-2">
<h2 id="org09c1971"><span class="section-number-2">13.</span> Objects in depth</h2>
<div class="outline-text-2" id="text-13">
<p>
Objects contain one or more key-value pairs. The key portion can be any
string. The value portion can be any type of value: a number, a string,
an array, a function, or even another object.
</p>


<p>
As you know objects are collections of name-value pairs. An object can have te following values for its names:
</p>
<ul class="org-ul">
<li>primitive property</li>
<li>object property</li>
<li>function method</li>
</ul>

<p>
The values do not live inside the object, but the object keeps references to them.
</p>


<div id="orgdbc0fb7" class="figure">
<p><img src="img/objects_in_depth.png" alt="objects_in_depth.png" />
</p>
</div>
</div>


<div id="outline-container-org20b707f" class="outline-3">
<h3 id="org20b707f"><span class="section-number-3">13.1.</span> The Comupted Member Access Operator</h3>
<div class="outline-text-3" id="text-13-1">
<p>
When accessing the properties of an object using square brackets,
it is using the <code>computed member access operator - []</code>.
</p>

<p>
If you are not using the CAM module, the <code>member access operator - .</code> can be used.
</p>

<p>
The member access operator can be used interchangeably with the computed
member access operator.
</p>

<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">person</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Object</span>();

   person[<span style="color: #98be65;">"firstname"</span>] = <span style="color: #98be65;">"Jon"</span>;
   person[<span style="color: #98be65;">"lastname"</span>] = <span style="color: #98be65;">"Doe"</span>;

   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">firstNameProperty</span> = <span style="color: #98be65;">"firstname"</span>;

   console.log(person);
   console.log(person[firstNameProperty]);

   console.log(person.firstname);
   console.log(person.lastname);

   person.address = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Object</span>();
   person.address.street = <span style="color: #98be65;">"111 Main St."</span>;
   person.address.city = <span style="color: #98be65;">"New York"</span>;
   person.address.state = <span style="color: #98be65;">"NY"</span>;

   console.log(person.address.street);
   console.log(person.address.city);
   console.log(person[<span style="color: #98be65;">"address"</span>][<span style="color: #98be65;">"state"</span>]);
</pre>
</div>


<p>
[Definition: When one of these values is a function, it&rsquo;s called a
<code>method</code> of the object.] Otherwise, they are called properties.
</p>

<p>
As it turns out, nearly everything in JavaScript is an object &#x2014;
arrays, functions, numbers, even strings &#x2014; and they all have
properties and methods.
</p>

<p>
<b>Creating an &ldquo;object literal&rdquo;</b>
</p>

<p>
Creating object using an object literal is the preferred way of creating objects.
</p>

<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">Tony</span> = {
     firstname: <span style="color: #98be65;">'Tony'</span>,
     lastname: <span style="color: #98be65;">'Parker'</span>,
     address: {
       street: <span style="color: #98be65;">'111 Main St.'</span>,
       city: <span style="color: #98be65;">'New York'</span>,
       state: <span style="color: #98be65;">'NY'</span>
     }
   };

   <span style="color: #51afef;">function</span> <span style="color: #c678dd;">greet</span>(<span style="color: #dcaeea;">person</span>) {
     console.log(<span style="color: #98be65;">'Hi '</span> + person.firstname);
   }

   greet(Tony);

   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Creating the object in the function call...</span>
   greet({
    firstname: <span style="color: #98be65;">'Mary'</span>,
    lastname: <span style="color: #98be65;">'Doe'</span>
   });

   Tony.address2 = {
    street: <span style="color: #98be65;">'333 Second St.'</span>
   }

</pre>
</div>
</div>
</div>

<div id="outline-container-org856af28" class="outline-3">
<h3 id="org856af28"><span class="section-number-3">13.2.</span> Faking namespaces in JavaScript</h3>
<div class="outline-text-3" id="text-13-2">
<p>
Namespaces are containers for functions and variables.
In JavaScript, the collision is avoided using objects.
This is a functionality that is commonly used in modern JavaScript.
</p>

<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">greet</span> = <span style="color: #98be65;">'Hello!'</span>;
   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">greet</span> = <span style="color: #98be65;">'Hola!'</span>;

   console.log(greet);

   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">english</span> = {
    greetings: {
        basic: <span style="color: #98be65;">'Hello!'</span>
    }
   };

   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">spanish</span> = {};

   spanish.greet = <span style="color: #98be65;">'Hola!'</span>;

   console.log(english);
</pre>
</div>
</div>
</div>


<div id="outline-container-org6bfd9a7" class="outline-3">
<h3 id="org6bfd9a7"><span class="section-number-3">13.3.</span> Note</h3>
<div class="outline-text-3" id="text-13-3">
<p>
When creating object literals, you should note that the key portion of
each key-value pair can be written as any valid JavaScript identifier, a
string (wrapped in quotes) or a number:
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myObject</span> = {
        validIdentifier: <span style="color: #da8548; font-weight: bold;">123</span>,
        <span style="color: #98be65;">'some string'</span>: <span style="color: #da8548; font-weight: bold;">456</span>,
        <span style="color: #da8548; font-weight: bold;">99999</span>: <span style="color: #da8548; font-weight: bold;">789</span>
    };
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org424516f" class="outline-2">
<h2 id="org424516f"><span class="section-number-2">14.</span> Closures</h2>
<div class="outline-text-2" id="text-14">
<p>
Definition:
</p>
<blockquote>
<p>
<b>Closures are an extension of the concept of scope &#x2014; functions have access to variables that were available in the scope where the function was created.</b>
</p>
</blockquote>

<p>
Another definition of closures can be summarized as:
</p>
<blockquote>
<p>
<b>Closure is when a function &ldquo;remembers&rdquo; its lexical scope even when the function is executed outside that lexical scope.</b>
</p>
</blockquote>

<p>
By these definitions, <i><b>all functions are closures</b></i> in JavaScript.
</p>

<p>
The same sort of behavior exists with functions defined within loops &#x2014; the function &ldquo;sees&rdquo; the change in the variable&rsquo;s value even after the function is defined, resulting in all clicks alerting 5.
</p>

<p>
Consider the following example:
</p>
<div class="org-src-container">
<pre class="src src-javascript">  <span style="color: #51afef;">function</span> <span style="color: #c678dd;">makeAdder</span>(<span style="color: #dcaeea;">a</span>) {
    <span style="color: #51afef;">return</span> <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">b</span>) {
      <span style="color: #51afef;">return</span> a + b;
    };
  }
  x = makeAdder(<span style="color: #da8548; font-weight: bold;">5</span>);
  y = makeAdder(<span style="color: #da8548; font-weight: bold;">20</span>);
  console.log(x(<span style="color: #da8548; font-weight: bold;">6</span>));
  console.log(y(<span style="color: #da8548; font-weight: bold;">7</span>))
</pre>
</div>
<p>
What&rsquo;s happening here is pretty much the same as was happening with the
inner functions earlier on: a function defined inside another function
has access to the outer function&rsquo;s variables. The only difference here
is that the outer function has returned, and hence common sense would
seem to dictate that its local variables no longer exist. But
they <b>do</b> still exist &#x2014; otherwise the adder functions would be unable
to work. What&rsquo;s more, there are two different &ldquo;copies&rdquo; of <code>makeAdder's</code>
local variables &#x2014; one in which <code>a</code> is <code>5</code> and one in which <code>a</code> is <code>20</code>. So the
result of those function calls is as follows:
</p>

<div class="org-src-container">
<pre class="src src-javascript">x(<span style="color: #da8548; font-weight: bold;">6</span>) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 11</span>

y(<span style="color: #da8548; font-weight: bold;">7</span>) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 27</span>
</pre>
</div>

<p>
Here&rsquo;s what&rsquo;s actually happening. Whenever JavaScript executes a
function, a &rsquo;scope&rsquo; object is created to hold the local variables
created within that function. It is initialized with any variables
passed in as function parameters. This is similar to the global object
that all global variables and functions live in, but with a couple of
important differences: firstly, a brand new scope object is created
every time a function starts executing, and secondly, unlike the global
object (which is accessible as this and in browsers is accessible
as window) these scope objects cannot be directly accessed from your
JavaScript code. There is no mechanism for iterating over the properties
of the current scope object, for example.
</p>

<p>
So when <code>makeAdder</code> is called, a scope object is created with one
property: <code>a</code>, which is the argument passed to
the <code>makeAdder</code> function. <code>makeAdder</code> then returns a newly created function.
Normally JavaScript&rsquo;s garbage collector would clean up the scope object
created for <code>makeAdder</code> at this point, but the returned function maintains
a reference back to that scope object. As a result, the scope object
will not be garbage collected until there are no more references to the
function object that <code>makeAdder</code> returned.
</p>

<p>
Scope objects form a chain called the scope chain, similar to the
prototype chain used by JavaScript&rsquo;s object system.
</p>

<p>
A closure is the combination of a function and the scope object in which
it was created.
</p>

<p>
Closures let you save state &#x2014; as such, they can often be used in place
of objects. Several excellent introductions to closures can be
found <a href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work"><i>here</i></a>.
</p>

<p>
Let&rsquo;s analyse the following example and try to guess what it will print:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">function</span> <span style="color: #c678dd;">buildFunctions</span>() {

    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">arr</span> = [];

    <span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">3</span>; i++) {

        arr.push(
            <span style="color: #51afef;">function</span>() {
                console.log(i);
            }
        )

    }

    <span style="color: #51afef;">return</span> arr;
}

<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">fs</span> = buildFunctions();

fs[<span style="color: #da8548; font-weight: bold;">0</span>]();
fs[<span style="color: #da8548; font-weight: bold;">1</span>]();
fs[<span style="color: #da8548; font-weight: bold;">2</span>]();
</pre>
</div>

<p>
What about the following example?
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">function</span> <span style="color: #c678dd;">buildFunctions</span>() {

    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">arr</span> = [];

    <span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">3</span>; i++) {
        arr.push(
            (<span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">j</span>) {
                <span style="color: #51afef;">return</span> <span style="color: #51afef;">function</span>() {
                    console.log(j);
                }
            }(i))
        )

    }

    <span style="color: #51afef;">return</span> arr;
}

<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">fs2</span> = buildFunctions2();

fs2[<span style="color: #da8548; font-weight: bold;">0</span>]();
fs2[<span style="color: #da8548; font-weight: bold;">1</span>]();
fs2[<span style="color: #da8548; font-weight: bold;">2</span>]();
</pre>
</div>

<p>
An unfortunate side effect of closures is that they make it trivially
easy to leak memory in Internet Explorer. JavaScript is a garbage
collected language &#x2014; objects are allocated memory upon their creation
and that memory is reclaimed by the browser when no references to an
object remain. Objects provided by the host environment are handled by
that environment.
</p>

<p>
Browser hosts need to manage a large number of objects representing the
HTML page being presented &#x2014; the objects of
the <a href="https://developer.mozilla.org/en/DOM"><i>DOM</i></a>. It is up to the
browser to manage the allocation and recovery of these.
</p>

<p>
Internet Explorer uses its own garbage collection scheme for this,
separate from the mechanism used for JavaScript. It is the interaction
between the two that can cause memory leaks.
</p>

<p>
A memory leak in IE occurs any time a circular reference is formed
between a JavaScript object and a native object. Consider the following:
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">function</span> <span style="color: #c678dd;">leakMemory</span>() {

<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">el</span> = document.getElementById(<span style="color: #98be65;">'el'</span>);

<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">o</span> = { <span style="color: #98be65;">'el'</span>: el };

el.o = o;

}
</pre>
</div>
<p>
The circular reference formed above creates a memory leak; IE will not
free the memory used by <code>el</code> and <code>o</code> until the browser is completely
restarted.
</p>

<p>
The above case is likely to go unnoticed; memory leaks only become a
real concern in long running applications or applications that leak
large amounts of memory due to large data structures or leak patterns
within loops.
</p>

<p>
Leaks are rarely this obvious &#x2014; often the leaked data structure can
have many layers of references, obscuring the circular reference.
</p>

<p>
Closures make it easy to create a memory leak without meaning to.
Consider this:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">function</span> <span style="color: #c678dd;">addHandler</span>() {

<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">el</span> = document.getElementById(<span style="color: #98be65;">'el'</span>);

el.onclick = <span style="color: #51afef;">function</span>() {

el.style.backgroundColor = <span style="color: #98be65;">'red'</span>;

};

}
</pre>
</div>
<p>
The above code sets up the element to turn red when it is clicked. It
also creates a memory leak. Why? Because the reference to el is
inadvertently caught in the closure created for the anonymous inner
function. This creates a circular reference between a JavaScript object
(the function) and a native object (el).
</p>

<p>
There are a number of workarounds for this problem. The simplest is not
to use the el variable:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">function</span> <span style="color: #c678dd;">addHandler</span>(){

document.getElementById(<span style="color: #98be65;">'el'</span>).onclick = <span style="color: #51afef;">function</span>(){

<span style="color: #a9a1e1;">this</span>.style.backgroundColor = <span style="color: #98be65;">'red'</span>;

};

}
</pre>
</div>
<p>
Surprisingly, one trick for breaking circular references introduced by a
closure is to add another closure:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">function</span> <span style="color: #c678dd;">addHandler</span>() {

<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">clickHandler</span> = <span style="color: #51afef;">function</span>() {

<span style="color: #a9a1e1;">this</span>.style.backgroundColor = <span style="color: #98be65;">'red'</span>;

};

(<span style="color: #51afef;">function</span>() {

<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">el</span> = document.getElementById(<span style="color: #98be65;">'el'</span>);

el.onclick = clickHandler;

})();

}
</pre>
</div>
<p>
The inner function is executed straight away, and hides its contents
from the closure created with <code>clickHandler</code>.
</p>
</div>


<div id="outline-container-org043c5df" class="outline-3">
<h3 id="org043c5df"><span class="section-number-3">14.1.</span> Closure Examples</h3>
<div class="outline-text-3" id="text-14-1">
<p>
<b>How to lock in the value of <code>i</code>?</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">this won't behave as we want it to;</span><span style="color: #5B6268;"> */</span>
    <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">every click will alert 5</span><span style="color: #5B6268;"> */</span>
    <span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span>=<span style="color: #da8548; font-weight: bold;">0</span>; i&lt;<span style="color: #da8548; font-weight: bold;">5</span>; i++) {
        $(<span style="color: #98be65;">'&lt;p&gt;click me&lt;/p&gt;'</span>).appendTo(<span style="color: #98be65;">'body'</span>).click(<span style="color: #51afef;">function</span>() {
            alert(i);
        });
    }
</pre>
</div>

<p>
<b>Locking in the value of <code>i</code> with a closure</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">fix: 'close' the value of i inside</span>
<span style="color: #5B6268;">            createFunction, so it won't change</span><span style="color: #5B6268;"> */</span>
    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">createFunction</span> = <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">i</span>) {
        <span style="color: #51afef;">return</span> <span style="color: #51afef;">function</span>() { alert(i); };
    };

    <span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span>=<span style="color: #da8548; font-weight: bold;">0</span>; i&lt;<span style="color: #da8548; font-weight: bold;">5</span>; i++) {
        $(<span style="color: #98be65;">'&lt;p&gt;click me&lt;/p&gt;'</span>).appendTo(<span style="color: #98be65;">'body'</span>).click(createFunction(i));
    }
</pre>
</div>

<p>
Closures can also be used to resolve issues with the <code>this</code> keyword,
which is unique to each scope:
</p>

<p>
<b>Using a closure to access inner and outer object instances
simultaneously</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">outerObj</span> = {
        myName : <span style="color: #98be65;">'outer'</span>,
        <span style="color: #c678dd;">outerFunction</span> : <span style="color: #51afef;">function</span> () {

            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">provide a reference to outerObj</span>
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">through innerFunction's closure</span>
            <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">self</span> = <span style="color: #a9a1e1;">this</span>;

            <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">innerObj</span> = {
                myName : <span style="color: #98be65;">'inner'</span>,
                <span style="color: #c678dd;">innerFunction</span> : <span style="color: #51afef;">function</span> () {
                    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 'outer inner'</span>
                    console.log(self.myName, <span style="color: #a9a1e1;">this</span>.myName);
                }
            };

            innerObj.innerFunction();

            console.log(<span style="color: #a9a1e1;">this</span>.myName); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs 'outer'</span>
        }
    };

    outerObj.outerFunction();
</pre>
</div>

<p>
This mechanism can be particularly useful when dealing with callbacks,
though in those cases, it is often better to use
<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Function.bind</a>,
which will avoid any overhead associated with scope traversal.
</p>
</div>
</div>
</div>


<div id="outline-container-orgabb5a65" class="outline-2">
<h2 id="orgabb5a65"><span class="section-number-2">15.</span> Testing Type</h2>
<div class="outline-text-2" id="text-15">
<p>
  JavaScript offers a way to test the &ldquo;type&rdquo; of a variable. However, the
result can be confusing &#x2014; for example, the type of an Array is
&ldquo;object&rdquo;.
</p>

<p>
It&rsquo;s common practice to use the <code>typeof</code> operator when trying to
determining the type of a specific value.
</p>

<p>
<b>Testing the type of various variables</b>
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myFunction</span> = <span style="color: #51afef;">function</span>() {
        console.log(<span style="color: #98be65;">'hello'</span>);
    };

    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myObject</span> = {
        foo : <span style="color: #98be65;">'bar'</span>
    };

    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myArray</span> = [ <span style="color: #98be65;">'a'</span>, <span style="color: #98be65;">'b'</span>, <span style="color: #98be65;">'c'</span> ];

    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myString</span> = <span style="color: #98be65;">'hello'</span>;

    <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">myNumber</span> = <span style="color: #da8548; font-weight: bold;">3</span>;

    <span style="color: #51afef;">typeof</span> myFunction;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 'function'</span>
    <span style="color: #51afef;">typeof</span> myObject;     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 'object'</span>
    <span style="color: #51afef;">typeof</span> myArray;      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 'object' -- careful!</span>
    <span style="color: #51afef;">typeof</span> myString;     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 'string';</span>
    <span style="color: #51afef;">typeof</span> myNumber;     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 'number'</span>

    <span style="color: #51afef;">typeof</span> <span style="color: #a9a1e1;">null</span>;         <span style="color: #5B6268;">// </span><span style="color: #5B6268;">returns 'object' -- careful!</span>


    <span style="color: #51afef;">if</span> (myArray.push &amp;&amp; myArray.slice &amp;&amp; myArray.join) {
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">probably an array</span>
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">(this is called "duck typing")</span>
    }

    <span style="color: #51afef;">if</span> (Object.<span style="color: #a9a1e1;">prototype</span>.toString.call(myArray) === <span style="color: #98be65;">'[object Array]'</span>) {
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Definitely an array!</span>
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">This is widely considered as the most robust way</span>
        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">to determine if a specific value is an Array.</span>
    }
</pre>
</div>

<p>
jQuery offers utility methods to help you determine the type of an
arbitrary value.
</p>
</div>
</div>

<div id="outline-container-orgdcd1e61" class="outline-2">
<h2 id="orgdcd1e61"><span class="section-number-2">16.</span> Prototype-based programming</h2>
<div class="outline-text-2" id="text-16">
<p>
Prototype-based programming is an OOP model that doesn&rsquo;t use classes, but rather it first accomplishes the behavior of any class and then reuses it (equivalent to inheritance in class-based languages) by decorating (or expanding upon) existing <b>prototype</b> objects. (Also called <i>classless</i>, <i>prototype-oriented</i>, or <i>instance-based programming</i>.)
</p>

<p>
The original (and most canonical) example of a prototype-based language is <code>Self</code> developed by David Ungar and Randall Smith. However, the class-less programming style grows increasingly popular lately, and has been adopted for programming languages such as JavaScript, Lua and several others.
</p>
</div>

<div id="outline-container-org3d3abbb" class="outline-3">
<h3 id="org3d3abbb"><span class="section-number-3">16.1.</span> Standard built-in objects</h3>
<div class="outline-text-3" id="text-16-1">
<p>
JavaScript has several objects included in its core, for example, there are objects like Math, Object, Array, and String. The example below shows how to use the <code>Math</code> object to get a random number by using its <code>random()</code> method.
</p>

<div class="org-src-container">
<pre class="src src-javascript">    console.log(Math.random());
</pre>
</div>

<p>
See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">JavaScript Reference: Standard built-in objects</a> for a list of the core objects in JavaScript.
</p>

<p>
Every object in JavaScript is an instance of the object <code>Object</code> and therefore inherits all its properties and methods. 
</p>
</div>
</div>

<div id="outline-container-org1299d0f" class="outline-3">
<h3 id="org1299d0f"><span class="section-number-3">16.2.</span> Custom objects</h3>
<div class="outline-text-3" id="text-16-2">
<p>
JavaScript is a prototype-based language and (until ES6) does not contain a <code>class</code> statement, such as is found in C++ or Java. This is sometimes confusing for programmers accustomed to languages with a <code>class</code> statement. Instead, JavaScript uses functions as classes. Defining a class is as easy as defining a function. In the example below we define a new class called Person.
</p>

<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">Person</span> = <span style="color: #51afef;">function</span> () {};
</pre>
</div>
</div>
</div>

<div id="outline-container-org58c80e7" class="outline-3">
<h3 id="org58c80e7"><span class="section-number-3">16.3.</span> The object (class instance)</h3>
<div class="outline-text-3" id="text-16-3">
<p>
To create a new instance of an object <code>obj</code> we use the statement <code>new obj</code>,
assigning the result (which is of type obj) to a variable to access it later.
</p>

<p>
In the example above we define a class named Person.
In the example below we create two instances (person1 and person2).
</p>

<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">person1</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Person</span>();
   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">person2</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Person</span>();
</pre>
</div>

<p>
Note: Please see Object.create() for a new, additional, instantiation method
that creates an uninitialized instance.
</p>
</div>
</div>

<div id="outline-container-orgb4fdda6" class="outline-3">
<h3 id="orgb4fdda6"><span class="section-number-3">16.4.</span> The constructor</h3>
<div class="outline-text-3" id="text-16-4">
<p>
The constructor is called at the moment of instantiation
(the moment when the object instance is created).
The constructor is a method of the class.
In JavaScript the function serves as the constructor of the object,
therefore there is no need to explicitly define a constructor method.
Every action declared in the class gets executed at the time of instantiation.
</p>

<p>
The constructor is used to set the object&rsquo;s properties or to call methods to prepare the object for use.
Adding class methods and their definitions occurs using a different syntax described later in this article.
</p>

<p>
In the example below, the constructor of the <code>class Person</code> logs a message when a Person is instantiated.
</p>

<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">Person</span> = <span style="color: #51afef;">function</span> () {
     console.log(<span style="color: #98be65;">'instance created'</span>);
   };
   
   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">person1</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Person</span>();
   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">person2</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Person</span>();
</pre>
</div>

<p>
The property (object attribute)
</p>

<p>
Properties are variables contained in the class; every instance of the object
has those properties. Properties are set in the constructor (function) of the
class so that they are created on each instance.
</p>

<p>
The keyword <code>this</code>, which refers to the current object,
lets you work with properties from within the class.
Accessing (reading or writing) a property outside of the class is done with the syntax:
<code>InstanceName.Property</code>, just like in C++, Java, and several other languages.
(Inside the class the syntax this.Property is used to get or set the property&rsquo;s value.)
</p>

<p>
In the example below, we define the firstName property for the Person class at instantiation:
</p>

<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">Person</span> = <span style="color: #51afef;">function</span> (<span style="color: #dcaeea;">firstName</span>) {
     <span style="color: #a9a1e1;">this</span>.firstName = firstName;
     console.log(<span style="color: #98be65;">'Person instantiated'</span>);
   };
   
   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">person1</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Person</span>(<span style="color: #98be65;">'Alice'</span>);
   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">person2</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Person</span>(<span style="color: #98be65;">'Bob'</span>);

   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Show the firstName properties of the objects</span>
   console.log(<span style="color: #98be65;">'person1 is '</span> + person1.firstName); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs "person1 is Alice"</span>
   console.log(<span style="color: #98be65;">'person2 is '</span> + person2.firstName); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs "person2 is Bob"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org1f428e4" class="outline-3">
<h3 id="org1f428e4"><span class="section-number-3">16.5.</span> The methods</h3>
<div class="outline-text-3" id="text-16-5">
<p>
Methods are functions (and defined like functions), but otherwise follow the
same logic as properties. Calling a method is similar to accessing a property,
but you add () at the end of the method name, possibly with arguments.
To define a method, assign a function to a named property of the class&rsquo;s prototype property.
Later, you can call the method on the object by the same name as you assigned the function to.
</p>

<p>
In the example below, we define and use the method sayHello() for the Person class.
</p>

<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">Person</span> = <span style="color: #51afef;">function</span> (<span style="color: #dcaeea;">firstName</span>) {
     <span style="color: #a9a1e1;">this</span>.firstName = firstName;
   };

   Person.<span style="color: #a9a1e1;">prototype</span>.sayHello = <span style="color: #51afef;">function</span>() {
     console.log(<span style="color: #98be65;">"Hello, I'm "</span> + <span style="color: #a9a1e1;">this</span>.firstName);
   };

   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">person1</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Person</span>(<span style="color: #98be65;">"Alice"</span>);
   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">person2</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Person</span>(<span style="color: #98be65;">"Bob"</span>);

   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">call the Person sayHello method.</span>
   person1.sayHello(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs "Hello, I'm Alice"</span>
   person2.sayHello(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs "Hello, I'm Bob"</span>
</pre>
</div>

<p>
In JavaScript methods are regular function objects bound to an object as a property,
which means you can invoke methods &ldquo;out of the context&rdquo;.
Consider the following example code:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">var</span> <span style="color: #dcaeea;">Person</span> = <span style="color: #51afef;">function</span> (<span style="color: #dcaeea;">firstName</span>) {
  <span style="color: #a9a1e1;">this</span>.firstName = firstName;
};

Person.<span style="color: #a9a1e1;">prototype</span>.sayHello = <span style="color: #51afef;">function</span>() {
  console.log(<span style="color: #98be65;">"Hello, I'm "</span> + <span style="color: #a9a1e1;">this</span>.firstName);
};

<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">person1</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Person</span>(<span style="color: #98be65;">"Alice"</span>);
<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">person2</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Person</span>(<span style="color: #98be65;">"Bob"</span>);
<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">helloFunction</span> = person1.sayHello;

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs "Hello, I'm Alice"</span>
person1.sayHello();

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs "Hello, I'm Bob"</span>
person2.sayHello();

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs "Hello, I'm undefined" (or fails</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">with a TypeError in strict mode)</span>
helloFunction();

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs true</span>
console.log(helloFunction === person1.sayHello);

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs true</span>
console.log(helloFunction === Person.<span style="color: #a9a1e1;">prototype</span>.sayHello);

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs "Hello, I'm Alice"</span>
helloFunction.call(person1);
</pre>
</div>

<p>
As that example shows, all of the references we have to the <code>sayHello</code> function
&#x2014; the one on person1, on Person.prototype, in the helloFunction variable, etc.
&#x2014; refer to the same function. The value of this during a call to the function
depends on how we call it. Most commonly, when we call this in an expression
where we got the function from an object property &#x2014; <code>person1.sayHello()</code>
&#x2014; this is set to the object we got the function from (person1),
which is why <code>person1.sayHello()</code> uses the name &ldquo;Alice&rdquo; and person2.sayHello()
uses the name &ldquo;Bob&rdquo;. But if we call it other ways, this is set differently:
calling this from a variable <code>helloFunction()</code> sets this to the global object
(window, on browsers). Since that object (probably) doesn&rsquo;t have a <code>firstName</code>
property, we end up with &ldquo;Hello, I&rsquo;m undefined&rdquo;.
(That&rsquo;s in loose mode code; it would be different [an error] in strict mode,
but to avoid confusion we won&rsquo;t go into detail here.)
Or we can set this explicitly using <code>Function.call</code> (or <code>Function.apply</code>),
as shown at the end of the example.
</p>
</div>
</div>

<div id="outline-container-org7eecbd8" class="outline-3">
<h3 id="org7eecbd8"><span class="section-number-3">16.6.</span> Inheritance</h3>
<div class="outline-text-3" id="text-16-6">
<p>
Inheritance is a way to create a class as a specialized version of one or more
classes (JavaScript only supports single inheritance).
The specialized class is commonly called the child, and the other class is
commonly called the parent.
In JavaScript you do this by assigning an instance of the parent class to the
child class, and then specializing it.
In modern browsers you can also use <code>Object.create</code> to implement inheritance.
</p>

<p>
Note: JavaScript does not detect the child class prototype.constructor
(see <code>Object.prototype</code>), so we must state that manually. See the question
<a href="http://stackoverflow.com/questions/8453887/why-is-it-necessary-to-set-the-prototype-constructor">Why is it necessary to set the prototype constructor?</a> on Stackoverflow.
</p>

<p>
In the example below, we define the class Student as a child class of Person.
Then we redefine the sayHello() method and add the sayGoodBye() method.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">Define the Person constructor</span>
<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">Person</span> = <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">firstName</span>) {
  <span style="color: #a9a1e1;">this</span>.firstName = firstName;
};

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Add a couple of methods to Person.prototype</span>
Person.<span style="color: #a9a1e1;">prototype</span>.walk = <span style="color: #51afef;">function</span>(){
  console.log(<span style="color: #98be65;">"I am walking!"</span>);
};

Person.<span style="color: #a9a1e1;">prototype</span>.sayHello = <span style="color: #51afef;">function</span>(){
  console.log(<span style="color: #98be65;">"Hello, I'm "</span> + <span style="color: #a9a1e1;">this</span>.firstName);
};

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Define the Student constructor</span>
<span style="color: #51afef;">function</span> <span style="color: #c678dd;">Student</span>(<span style="color: #dcaeea;">firstName</span>, <span style="color: #dcaeea;">subject</span>) {
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Call the parent constructor, making sure (using Function#call)</span>
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">that "this" is set correctly during the call</span>
  Person.call(<span style="color: #a9a1e1;">this</span>, firstName);

  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Initialize our Student-specific properties</span>
  <span style="color: #a9a1e1;">this</span>.subject = subject;
};

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Create a Student.prototype object that inherits from Person.prototype.</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Note: A common error here is to use "new Person()" to create the</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Student.prototype. That's incorrect for several reasons, not least</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">that we don't have anything to give Person for the "firstName"</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">argument. The correct place to call Person is above, where we call</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">it from Student.</span>
Student.<span style="color: #a9a1e1;">prototype</span> = Object.create(Person.<span style="color: #a9a1e1;">prototype</span>); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">See note below</span>

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Set the "constructor" property to refer to Student</span>
Student.<span style="color: #a9a1e1;">prototype</span>.constructor = Student;

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Replace the "sayHello" method</span>
Student.<span style="color: #a9a1e1;">prototype</span>.sayHello = <span style="color: #51afef;">function</span>(){
  console.log(<span style="color: #98be65;">"Hello, I'm "</span> + <span style="color: #a9a1e1;">this</span>.firstName + <span style="color: #98be65;">". I'm studying "</span>
              + <span style="color: #a9a1e1;">this</span>.subject + <span style="color: #98be65;">"."</span>);
};

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Add a "sayGoodBye" method</span>
Student.<span style="color: #a9a1e1;">prototype</span>.sayGoodBye = <span style="color: #51afef;">function</span>(){
  console.log(<span style="color: #98be65;">"Goodbye!"</span>);
};

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Example usage:</span>
<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">student1</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Student</span>(<span style="color: #98be65;">"Janet"</span>, <span style="color: #98be65;">"Applied Physics"</span>);
student1.sayHello();   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"Hello, I'm Janet. I'm studying Applied Physics."</span>
student1.walk();       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"I am walking!"</span>
student1.sayGoodBye(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"Goodbye!"</span>

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Check that instanceof works correctly</span>
console.log(student1 <span style="color: #51afef;">instanceof</span> <span style="color: #ECBE7B;">Person</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">true</span>
console.log(student1 <span style="color: #51afef;">instanceof</span> <span style="color: #ECBE7B;">Student</span>); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">true</span>
</pre>
</div>

<p>
Regarding the Student.prototype = Object.create(Person.prototype); line:
On older JavaScript engines without Object.create, one can either use a
&ldquo;polyfill&rdquo; (aka &ldquo;shim&rdquo;, see the linked article),
or one can use a function that achieves the same result, such as:
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">function</span> <span style="color: #c678dd;">createObject</span>(<span style="color: #dcaeea;">proto</span>) {
    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">ctor</span>() { }
    ctor.<span style="color: #a9a1e1;">prototype</span> = proto;
    <span style="color: #51afef;">return</span> <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">ctor</span>();
}

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Usage:</span>
Student.<span style="color: #a9a1e1;">prototype</span> = createObject(Person.<span style="color: #a9a1e1;">prototype</span>);
</pre>
</div>

<p>
Note: See <code>Object.create</code> for more on what it does, and a shim for older engines.
</p>

<p>
Making sure that this points to the right thing regardless of how the object is
instantiated can be difficult. However, there is a simple idiom to make this easier.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">var</span> <span style="color: #dcaeea;">Person</span> = <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">firstName</span>) {
  <span style="color: #51afef;">if</span> (<span style="color: #a9a1e1;">this</span> <span style="color: #51afef;">instanceof</span> <span style="color: #ECBE7B;">Person</span>) {
    <span style="color: #a9a1e1;">this</span>.firstName = firstName;
  } <span style="color: #51afef;">else</span> {
    <span style="color: #51afef;">return</span> <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Person</span>(firstName);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8056187" class="outline-3">
<h3 id="org8056187"><span class="section-number-3">16.7.</span> Encapsulation</h3>
<div class="outline-text-3" id="text-16-7">
<p>
In the previous example, <code>Student</code> does not need to know how the <code>Person</code>
class&rsquo;s walk() method is implemented, but still can use that method; the <code>Student</code>
class doesn&rsquo;t need to explicitly define that method unless we want to change it.
This is called encapsulation, by which every class packages data and methods into a single unit.
</p>

<p>
Information hiding is a common feature in other languages often as private and
protected methods/properties. Even though you could simulate something like this on JavaScript,
this is not a requirement to do Object Oriented programming.2
</p>
</div>
</div>

<div id="outline-container-orge3e16a0" class="outline-3">
<h3 id="orge3e16a0"><span class="section-number-3">16.8.</span> Abstraction</h3>
<div class="outline-text-3" id="text-16-8">
<p>
Abstraction is a mechanism that allows you to model the current part of the working problem,
either by inheritance (specialization) or composition.
JavaScript achieves specialization by inheritance, and composition
by letting class instances be the values of other objects&rsquo; attributes.
</p>

<p>
The JavaScript Function class inherits from the <code>Object</code> class
(this demonstrates specialization of the model) and the <code>Function.prototype</code>
property is an instance of Object (this demonstrates composition).
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #51afef;">var</span> <span style="color: #dcaeea;">foo</span> = <span style="color: #51afef;">function</span> () {};

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs "foo is a Function: true"</span>
console.log(<span style="color: #98be65;">'foo is a Function: '</span> + (foo <span style="color: #51afef;">instanceof</span> <span style="color: #ECBE7B;">Function</span>));

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">logs "foo.prototype is an Object: true"</span>
console.log(<span style="color: #98be65;">'foo.prototype is an Object: '</span> + (foo.<span style="color: #a9a1e1;">prototype</span> <span style="color: #51afef;">instanceof</span> <span style="color: #ECBE7B;">Object</span>));
</pre>
</div>
</div>
</div>

<div id="outline-container-org762c8e5" class="outline-3">
<h3 id="org762c8e5"><span class="section-number-3">16.9.</span> Polymorphism</h3>
<div class="outline-text-3" id="text-16-9">
<p>
Just as all methods and properties are defined inside the prototype property,
different classes can define methods with the same name; methods are scoped to
the class in which they&rsquo;re defined, unless the two classes hold a parent-child relation1qqq
(i.e. one inherits from the other in a chain of inheritance).
</p>
</div>
</div>

<div id="outline-container-org944aeb1" class="outline-3">
<h3 id="org944aeb1"><span class="section-number-3">16.10.</span> Real World Examples</h3>
<div class="outline-text-3" id="text-16-10">
<p>
Please check the <code>lib/lodash.js</code> and <code>lib/jquery.js</code> and review the libraries for objects, module pattern, function patterns etc.
</p>
</div>
</div>
</div>


<div id="outline-container-orga0ac1e2" class="outline-2">
<h2 id="orga0ac1e2"><span class="section-number-2">17.</span> EcmaScript 2015 (ES6) and beyond</h2>
<div class="outline-text-2" id="text-17">
<p>
ECMAScript 6, also known as ECMAScript 2015, is the latest version of the ECMAScript standard. ES6 is a significant update to the language, and the first update to the language since ES5 was standardized in 2009. Implementation of these features in major JavaScript engines is underway now. For reference if some of the features is supported, refer to <a href="https://kangax.github.io/compat-table/es6/">https://kangax.github.io/compat-table/es6/</a>.
</p>

<p>
See the <a href="http://www.ecma-international.org/ecma-262/6.0/">ES6 standard</a> for full specification of the ECMAScript 6 language.
</p>

<p>
The most notable ES6 features include:
</p>
</div>

<div id="outline-container-org1fe9e91" class="outline-3">
<h3 id="org1fe9e91"><span class="section-number-3">17.1.</span> Arrow functions</h3>
<div class="outline-text-3" id="text-17-1">
<p>
<b>Arrows</b> are a function shorthand using the <code>=&gt;</code> syntax. They are syntactically similar to the related feature in C#, Java 8 and CoffeeScript. They support both statement block bodies as well as expression bodies which return the value of the expression. Unlike functions, arrows <b>share the same lexical <code>this</code></b> as their surrounding code.
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">Arrow functions</span>

<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">evens</span> = [<span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">6</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">10</span>]; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Create an array</span>
console.log(<span style="color: #98be65;">"evens: "</span>, evens);

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Expression bodies</span>

<span style="color: #5B6268;">//</span><span style="color: #5B6268;">The code:</span>
<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">odds</span> = evens.map(<span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">v</span>){<span style="color: #51afef;">return</span> v + <span style="color: #da8548; font-weight: bold;">1</span>} );

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Can be written as:</span>
<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">odds_arrow</span> = evens.map(v =&gt; v + <span style="color: #da8548; font-weight: bold;">1</span>);

console.log(<span style="color: #98be65;">"odds: "</span>, odds, <span style="color: #98be65;">'\n'</span>, <span style="color: #98be65;">'odds_arrow:'</span>, odds_arrow);

<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">nums</span> = evens.map((v, i) =&gt; v + i);
<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">pairs</span> = evens.map(v =&gt; ({even: v, odd: v + <span style="color: #da8548; font-weight: bold;">1</span>}));

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Statement bodies</span>
nums.forEach(v =&gt; {
    <span style="color: #51afef;">if</span> (v % <span style="color: #da8548; font-weight: bold;">5</span> === <span style="color: #da8548; font-weight: bold;">0</span>)
        fives.push(v);
});

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Lexical this</span>
<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">bob</span> = {
    _name: <span style="color: #98be65;">"Bob"</span>,
    _friends: [],
    printFriends() {
        <span style="color: #a9a1e1;">this</span>._friends.forEach(f =&gt;
                              console.log(<span style="color: #a9a1e1;">this</span>._name + <span style="color: #98be65;">" knows "</span> + f));
    }
};
</pre>
</div>
</div>

<div id="outline-container-org2676c9e" class="outline-4">
<h4 id="org2676c9e"><span class="section-number-4">17.1.1.</span> In detail</h4>
<div class="outline-text-4" id="text-17-1-1">
<p>
The ES6 JavaScript update has introduced <i>arrow functions</i>, which is another way to declare and use functions. Here are the benefits they bring:
</p>
<ul class="org-ul">
<li>More concise</li>
<li><i>this</i> is picked up from surroundings</li>
<li>implicit return</li>
</ul>
</div>
</div>

<div id="outline-container-org4545847" class="outline-4">
<h4 id="org4545847"><span class="section-number-4">17.1.2.</span> Concision and implicit return</h4>
<div class="outline-text-4" id="text-17-1-2">
<div class="org-src-container">
<pre class="src src-js">     <span style="color: #51afef;">function</span> <span style="color: #c678dd;">double</span>(<span style="color: #dcaeea;">x</span>) { <span style="color: #51afef;">return</span> x * <span style="color: #da8548; font-weight: bold;">2</span>; } <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Traditional way</span>
     console.log(<span style="color: #ECBE7B;">double</span>(<span style="color: #da8548; font-weight: bold;">2</span>)) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">4</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-js">     <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">double</span> = x =&gt; x * <span style="color: #da8548; font-weight: bold;">2</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Same function written as an arrow function with implicit return</span>
     console.log(<span style="color: #ECBE7B;">double</span>(<span style="color: #da8548; font-weight: bold;">2</span>)) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">4</span>
</pre>
</div>

<p>
Arrow functions are more concise than traditional functions in many ways. Let&rsquo;s review all the possible cases:
</p>

<dl class="org-dl">
<dt>Implicit VS Explicit return</dt><dd>An <b>explicit return</b> is a function where the <i>return</i> keyword is used in its body.</dd>
</dl>
<div class="org-src-container">
<pre class="src src-js">     <span style="color: #51afef;">function</span> <span style="color: #c678dd;">double</span>(<span style="color: #dcaeea;">x</span>) {
      <span style="color: #51afef;">return</span> x * <span style="color: #da8548; font-weight: bold;">2</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">this function explicitly returns x * 2, *return* keyword is used</span>
     }
</pre>
</div>
<p>
In the traditional way of writing functions, the return was always explicit. But with arrow functions, you can do <i>implicit return</i> which means that you don&rsquo;t need to use the keyword <i>return</i> to return a value.
</p>
<div class="org-src-container">
<pre class="src src-js">     <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">double</span> = (x) =&gt; {
       <span style="color: #51afef;">return</span> x * <span style="color: #da8548; font-weight: bold;">2</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Explicit return here</span>
     }
</pre>
</div>
<p>
Since this function only returns something (no instructions before the <i>return</i> keyword) we can do an implicit return.
</p>
<div class="org-src-container">
<pre class="src src-js">     <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">double</span> = (x) =&gt; x * <span style="color: #da8548; font-weight: bold;">2</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Correct, returns x*2</span>
</pre>
</div>
<p>
To do so, we only need to <b>remove the brackets</b> and the <b>return</b> keyword. That&rsquo;s why it&rsquo;s called an <i>implicit</i> return, the <i>return</i> keyword is not there, but this function will indeed return <code>x * 2</code>.
</p>
<blockquote>
<p>
<b>Note:</b> If your function does not return a value (with <i>side effects</i>), it doesn&rsquo;t do an explicit nor an implicit return.
</p>
</blockquote>
<p>
Besides, if you want to implicitly return an <i>object</i> you <b>must have parentheses around it</b> since it will conflict with the block braces:
</p>
<div class="org-src-container">
<pre class="src src-js">     <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">getPerson</span> = () =&gt; ({ name: <span style="color: #98be65;">"Nick"</span>, age: <span style="color: #da8548; font-weight: bold;">24</span> })
     console.log(getPerson()) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">{ name: "Nick", age: 24 } -- object implicitly returned by arrow function</span>
</pre>
</div>

<dl class="org-dl">
<dt>Only one argument</dt><dd>If your function only takes one parameter, you can omit the parentheses around it. If we take back the above <i>double</i> code:</dd>
</dl>
<div class="org-src-container">
<pre class="src src-js">     <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">double</span> = (x) =&gt; x * <span style="color: #da8548; font-weight: bold;">2</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">this arrow function only takes one parameter</span>
</pre>
</div>
<p>
Parentheses around the parameter can be avoided:
</p>
<div class="org-src-container">
<pre class="src src-js">     <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">double</span> = x =&gt; x * <span style="color: #da8548; font-weight: bold;">2</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">this arrow function only takes one parameter</span>
</pre>
</div>

<dl class="org-dl">
<dt>No arguments</dt><dd>When there is no argument provided to an arrow function, you need to provide parentheses, or it won&rsquo;t be valid syntax.</dd>
</dl>
<div class="org-src-container">
<pre class="src src-js">     () =&gt; { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">parentheses are provided, everything is fine</span>
       <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">2</span>;
       <span style="color: #51afef;">return</span> x;
     }
</pre>
</div>

<div class="org-src-container">
<pre class="src src-js">     =&gt; { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">No parentheses, this won't work!</span>
       <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">2</span>;
       <span style="color: #51afef;">return</span> x;
     }
</pre>
</div>
</div>
</div>

<div id="outline-container-org96bcd81" class="outline-4">
<h4 id="org96bcd81"><span class="section-number-4">17.1.3.</span> <i>this</i> reference</h4>
<div class="outline-text-4" id="text-17-1-3">
<p>
In an arrow function, <i>this</i> is equal to the <i>this</i> value of the enclosing execution context. Basically, with arrow functions, you don&rsquo;t have to do the &ldquo;that = this&rdquo; trick before calling a function inside a function anymore.
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">myFunc</span>() {
      <span style="color: #a9a1e1;">this</span>.myVar = <span style="color: #da8548; font-weight: bold;">0</span>;
      setTimeout(() =&gt; {
        <span style="color: #a9a1e1;">this</span>.myVar++;
        console.log(<span style="color: #a9a1e1;">this</span>.myVar) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1</span>
      }, <span style="color: #da8548; font-weight: bold;">0</span>);
    }
</pre>
</div>

<p>
To understand this subtlety introduced with arrow functions, you must know how this behaves in JavaScript.
</p>

<p>
In an arrow function, <i>this</i> is equal to the <i>this</i> value of the enclosing execution context. What it means is that an arrow function doesn&rsquo;t create a new <i>this</i>, it grabs it from its surrounding instead.
</p>

<p>
Without arrow function, if you wanted to access a variable from <i>this</i> in a function inside a function, you had to use the <i>that = this</i> or <i>self = this</i> trick.
</p>

<p>
For instance, using setTimeout function inside myFunc:
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">myFunc</span>() {
      <span style="color: #a9a1e1;">this</span>.myVar = <span style="color: #da8548; font-weight: bold;">0</span>;
      <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">that</span> = <span style="color: #a9a1e1;">this</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">that = this trick</span>
      setTimeout(
        <span style="color: #51afef;">function</span>() { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">A new *this* is created in this function scope</span>
          that.myVar++;
          console.log(that.myVar) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1</span>

          console.log(<span style="color: #a9a1e1;">this</span>.myVar) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">undefined -- see function declaration above</span>
        },
        <span style="color: #da8548; font-weight: bold;">0</span>
      );
    }
</pre>
</div>

<p>
But with arrow function, <i>this</i> is taken from its surrounding:
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">myFunc</span>() {
      <span style="color: #a9a1e1;">this</span>.myVar = <span style="color: #da8548; font-weight: bold;">0</span>;
      setTimeout(
        () =&gt; { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">this taken from surrounding, meaning myFunc here</span>
          <span style="color: #a9a1e1;">this</span>.myVar++;
          console.log(<span style="color: #a9a1e1;">this</span>.myVar) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1</span>
        },
        <span style="color: #da8548; font-weight: bold;">0</span>
      );
    }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org24eca07" class="outline-3">
<h3 id="org24eca07"><span class="section-number-3">17.2.</span> Function default parameter value</h3>
<div class="outline-text-3" id="text-17-2">
<p>
Starting from ES2015 JavaScript update, you can set default value to your function parameters using the following syntax:
</p>
<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">function</span> <span style="color: #c678dd;">f</span>(<span style="color: #dcaeea;">x</span>, <span style="color: #dcaeea;">y</span>=<span style="color: #da8548; font-weight: bold;">12</span>) {
     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">y is 12 if not passed (or passed as undefined)</span>
     <span style="color: #51afef;">return</span> x + y;
   }
   f(<span style="color: #da8548; font-weight: bold;">3</span>) == <span style="color: #da8548; font-weight: bold;">15</span>
</pre>
</div>

<p>
The default parameter is applied in two and only two situations:
</p>
<ul class="org-ul">
<li>No parameter provided</li>
<li><i>undefined</i> parameter provided</li>
</ul>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">function</span> <span style="color: #c678dd;">myFunc</span>(<span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">10</span>) {
     <span style="color: #51afef;">return</span> x;
   }
   console.log(myFunc()) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10 -- no value is provided so x default value 10 is assigned to x in myFunc</span>
   console.log(myFunc(<span style="color: #da8548; font-weight: bold;">5</span>)) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">5 -- a value is provided so x is equal to 5 in myFunc</span>

   console.log(myFunc(<span style="color: #a9a1e1;">undefined</span>)) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10 -- undefined value is provided so default value is assigned to x</span>
   console.log(myFunc(<span style="color: #a9a1e1;">null</span>)) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">null -- a value (null) is provided, see below for more details</span>
</pre>
</div>
<p>
In other words, if you pass in <i>null</i> the default parameter <b>won&rsquo;t be applied</b>.
</p>

<blockquote>
<p>
<b>Note:</b> Default value assignment can be used with destructured parameters as well (see next notion to see an example)
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orga07edc7" class="outline-3">
<h3 id="orga07edc7"><span class="section-number-3">17.3.</span> Destructuring objects and arrays</h3>
<div class="outline-text-3" id="text-17-3">
<p>
<i>Destructuring</i> is a convenient way of creating new variables by extracting some values from data stored in objects or arrays.
</p>

<p>
To name a few use cases, <i>destructuring</i> can be used to destructure function parameters or <i>this.props</i> in React projects for instance.
</p>

<p>
<b>Explanation with sample code</b>
</p>
</div>

<div id="outline-container-orge44bdd9" class="outline-4">
<h4 id="orge44bdd9"><span class="section-number-4">17.3.1.</span> Object</h4>
<div class="outline-text-4" id="text-17-3-1">
<p>
Let&rsquo;s consider the following object for all the samples:
</p>
<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">person</span> = {
      firstName: <span style="color: #98be65;">"Nick"</span>,
      lastName: <span style="color: #98be65;">"Anderson"</span>,
      age: <span style="color: #da8548; font-weight: bold;">35</span>,
      sex: <span style="color: #98be65;">"M"</span>
    }
</pre>
</div>

<p>
Without destructuring:
</p>
<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">first</span> = person.firstName;
    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">age</span> = person.age;
    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">city</span> = person.city || <span style="color: #98be65;">"Paris"</span>;
</pre>
</div>

<p>
With destructuring, all in one line:
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> { firstName: first, age, city = <span style="color: #98be65;">"Paris"</span> } = person; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">That's it !</span>

    console.log(age) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">35 -- A new variable age is created and is equal to person.age</span>
    console.log(first) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"Nick" -- A new variable first is created and is equal to person.firstName</span>
    console.log(firstName) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Undefined -- person.firstName exists BUT the new variable created is named first</span>
    console.log(city) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"Paris" -- A new variable city is created and since person.city is undefined, city is equal to the default value provided "Paris".</span>
</pre>
</div>

<p>
<b>Note :</b> In <code>const { age } = person;</code>, the brackets after <i>const</i> keyword are not used to declare an object nor a block but is the <i>destructuring</i> syntax.
</p>
</div>
</div>

<div id="outline-container-org84c1dbb" class="outline-4">
<h4 id="org84c1dbb"><span class="section-number-4">17.3.2.</span> Function parameters</h4>
<div class="outline-text-4" id="text-17-3-2">
<p>
<i>Destructuring</i> is often used to destructure objects parameters in functions.
Without destructuring: 
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">joinFirstLastName</span>(<span style="color: #dcaeea;">person</span>) {
      <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">firstName</span> = person.firstName;
      <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">lastName</span> = person.lastName;
      <span style="color: #51afef;">return</span> firstName + <span style="color: #98be65;">'-'</span> + lastName;
    }

    joinFirstLastName(person); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"Nick-Anderson"</span>
</pre>
</div>

<p>
In destructuring the object parameter <i>person</i>, we get a more concise function:
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">joinFirstLastName</span>({ firstName, lastName }) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">we create firstName and lastName variables by destructuring person parameter</span>
      <span style="color: #51afef;">return</span> firstName + <span style="color: #98be65;">'-'</span> + lastName;
    }

    joinFirstLastName(person); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"Nick-Anderson"</span>
</pre>
</div>

<p>
Destructuring is even more pleasant to use with arrow functions:
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">joinFirstLastName</span> = ({ firstName, lastName }) =&gt; firstName + <span style="color: #98be65;">'-'</span> + lastName;

    joinFirstLastName(person); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"Nick-Anderson"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org745ac98" class="outline-4">
<h4 id="org745ac98"><span class="section-number-4">17.3.3.</span> Array</h4>
<div class="outline-text-4" id="text-17-3-3">
<p>
Let&rsquo;s consider the following array:
</p>
<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">myArray</span> = [<span style="color: #98be65;">"a"</span>, <span style="color: #98be65;">"b"</span>, <span style="color: #98be65;">"c"</span>];
</pre>
</div>

<p>
Without destructuring:
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">x</span> = myArray[<span style="color: #da8548; font-weight: bold;">0</span>];
    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">y</span> = myArray[<span style="color: #da8548; font-weight: bold;">1</span>]; 
</pre>
</div>

<p>
With destructuring: 
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> [<span style="color: #dcaeea;">x</span>, <span style="color: #dcaeea;">y</span>] = myArray; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">That's it !</span>

    console.log(x) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"a"</span>
    console.log(y) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"b"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org909a83b" class="outline-3">
<h3 id="org909a83b"><span class="section-number-3">17.4.</span> Array methods - map / filter / reduce</h3>
<div class="outline-text-3" id="text-17-4">
<p>
<i>Map</i>, <i>filter</i> and <i>reduce</i> are array methods that are coming from a programming paradigm named <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0"><i>functional programming</i></a>.
</p>

<p>
To sum it up:
</p>
<ul class="org-ul">
<li><b>Array.prototype.map()</b> takes an array, does something on its elements and returns an array with the transformed elements.</li>
<li><b>Array.prototype.filter()</b> takes an array, decides element by element if it should keep it or not and returns an array with the kept elements only</li>
<li><b>Array.prototype.reduce()</b> takes an array and aggregates the elements into a single value (which is returned)</li>
</ul>

<p>
Use them as much as possible in following the principles of functional programming because they are composable, concise and elegant.
</p>

<p>
With those three methods, you can avoid the use of <i>for</i> and <i>forEach</i> loops in most situations. When you are tempted to do a <i>for</i> loop, try to do it with <i>map</i>, <i>filter</i> and <i>reduce</i> composed. You might struggle to do it at first because it requires you to learn a new way of thinking, but once you&rsquo;ve got it things get easier.
</p>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">numbers</span> = [<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">6</span>];
   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">doubledNumbers</span> = numbers.map(n =&gt; n * <span style="color: #da8548; font-weight: bold;">2</span>); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">[0, 2, 4, 6, 8, 10, 12]</span>
   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">evenNumbers</span> = numbers.filter(n =&gt; n % <span style="color: #da8548; font-weight: bold;">2</span> === <span style="color: #da8548; font-weight: bold;">0</span>); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">[0, 2, 4, 6]</span>
   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">sum</span> = numbers.reduce((prev, next) =&gt; prev + next, <span style="color: #da8548; font-weight: bold;">0</span>); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">21</span>
</pre>
</div>
<p>
Compute total grade sum for students above 10 by composing map, filter and reduce:
</p>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">students</span> = [
     { name: <span style="color: #98be65;">"Nick"</span>, grade: <span style="color: #da8548; font-weight: bold;">10</span> },
     { name: <span style="color: #98be65;">"John"</span>, grade: <span style="color: #da8548; font-weight: bold;">15</span> },
     { name: <span style="color: #98be65;">"Julia"</span>, grade: <span style="color: #da8548; font-weight: bold;">19</span> },
     { name: <span style="color: #98be65;">"Nathalie"</span>, grade: <span style="color: #da8548; font-weight: bold;">9</span> },
   ];

   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">aboveTenSum</span> = students
     .map(student =&gt; student.grade) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">we map the students array to an array of their grades</span>
     .filter(grade =&gt; grade &gt;= <span style="color: #da8548; font-weight: bold;">10</span>) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">we filter the grades array to keep those above 10</span>
     .reduce((prev, next) =&gt; prev + next, <span style="color: #da8548; font-weight: bold;">0</span>); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">we sum all the grades above 10 one by one</span>

   console.log(aboveTenSum) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">44 -- 10 (Nick) + 15 (John) + 19 (Julia), Nathalie below 10 is ignored</span>
</pre>
</div>

<p>
Let&rsquo;s consider the following array of numbers for our examples:
</p>
<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">numbers</span> = [<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">6</span>];
</pre>
</div>

<dl class="org-dl">
<dt>Array.prototype.map()</dt><dd><div class="org-src-container">
<pre class="src src-js">     <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">doubledNumbers</span> = numbers.map(<span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">n</span>) {
       <span style="color: #51afef;">return</span> n * <span style="color: #da8548; font-weight: bold;">2</span>;
     });
     console.log(doubledNumbers); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">[0, 2, 4, 6, 8, 10, 12]</span>
</pre>
</div></dd>
</dl>
<p>
What&rsquo;s happening here? We are using .map on the <i>numbers</i> array, the map is iterating on each element of the array and passes it to our function. The goal of the function is to produce and return a new value from the one passed so that map can replace it.
</p>

<p>
Let&rsquo;s extract this function to make it more clear, just for this once:
</p>
<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">doubleN</span> = <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">n</span>) { <span style="color: #51afef;">return</span> n * <span style="color: #da8548; font-weight: bold;">2</span>; };
   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">doubledNumbers</span> = numbers.map(doubleN);
   console.log(doubledNumbers); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">[0, 2, 4, 6, 8, 10, 12]</span>
</pre>
</div>

<p>
<code>numbers.map(doubleN)</code> produces <code>[doubleN(0), doubleN(1), doubleN(2), doubleN(3), doubleN(4), doubleN(5), doubleN(6)]</code> which is equal to <code>[0, 2, 4, 6, 8, 10, 12]</code>.
</p>
<blockquote>
<p>
<b>Note:</b> If you do not need to return a new array and just want to do a loop that has side effects, you might just want to use a for / forEach loop instead of a map.
</p>
</blockquote>

<dl class="org-dl">
<dt>Array.prototype.filter()</dt><dd><div class="org-src-container">
<pre class="src src-js">     <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">evenNumbers</span> = numbers.filter(<span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">n</span>) {
       <span style="color: #51afef;">return</span> n % <span style="color: #da8548; font-weight: bold;">2</span> === <span style="color: #da8548; font-weight: bold;">0</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">true if "n" is par, false if "n" isn't</span>
     });
     console.log(evenNumbers); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">[0, 2, 4, 6]</span>
</pre>
</div>

<p>
We are using .filter on the <i>numbers</i> array, filter is iterating on each element of the array and passes it to our function. The goal of the function is to return a boolean that will determine whether the current value will be kept or not. Filter then returns the array with only the kept values.
</p></dd>

<dt>Array.prototype.reduce()</dt><dd><p>
The reduce method goal is to <i>reduce</i> all elements of the array it iterates on into a single value. How it aggregates those elements is up to you.
</p>
<div class="org-src-container">
<pre class="src src-js">     <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">sum</span> = numbers.reduce(
       <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">acc</span>, <span style="color: #dcaeea;">n</span>) {
         <span style="color: #51afef;">return</span> acc + n;
       },
       <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">accumulator variable value at first iteration step</span>
     );

     console.log(sum) <span style="color: #5B6268;">//</span><span style="color: #5B6268;">21</span>
</pre>
</div>

<p>
Just like for .map and .filter methods, .reduce is applied on an array and takes a function as the first parameter. This time though, there are changes:
</p>
<dl class="org-dl">
<dt>.reduce takes two parameters</dt><dd>the first parameter is a function that will be called at each iteration step. 
The second parameter is the value of the accumulator variable (<i>acc</i></dd>
</dl></dd>
</dl>
<p>
here) at the first iteration step (read next point to understand).
</p>

<dl class="org-dl">
<dt>Function parameters</dt><dd>The function you pass as the first parameter of .reduce takes two parameters. The first one (<i>acc</i> here) is the accumulator variable, whereas the second parameter (<i>n</i>) is the current element. 
The accumulator variable is equal to the return value of your function at the <b>previous</b> iteration step. At the first step of the iteration, <i>acc</i> is equal to the value you passed as .reduce second parameter.</dd>
</dl>
</div>
</div>

<div id="outline-container-org5c53f82" class="outline-3">
<h3 id="org5c53f82"><span class="section-number-3">17.5.</span> Spread operator &ldquo;&#x2026;&rdquo;</h3>
<div class="outline-text-3" id="text-17-5">
<p>
The spread operator <code>...</code> has been introduced with ES2015 and is used to expand elements of an iterable (like an array) into places where multiple elements can fit.
</p>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">arr1</span> = [<span style="color: #98be65;">"a"</span>, <span style="color: #98be65;">"b"</span>, <span style="color: #98be65;">"c"</span>];
   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">arr2</span> = [...arr1, <span style="color: #98be65;">"d"</span>, <span style="color: #98be65;">"e"</span>, <span style="color: #98be65;">"f"</span>]; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">["a", "b", "c", "d", "e", "f"]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">function</span> <span style="color: #c678dd;">myFunc</span>(<span style="color: #dcaeea;">x</span>, <span style="color: #dcaeea;">y</span>, ...<span style="color: #dcaeea;">params</span>) {
     console.log(x);
     console.log(y);
     console.log(params)
   }

   myFunc(<span style="color: #98be65;">"a"</span>, <span style="color: #98be65;">"b"</span>, <span style="color: #98be65;">"c"</span>, <span style="color: #98be65;">"d"</span>, <span style="color: #98be65;">"e"</span>, <span style="color: #98be65;">"f"</span>)
   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"a"</span>
   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"b"</span>
   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">["c", "d", "e", "f"]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">const</span> { x, y, ...z } = { x: <span style="color: #da8548; font-weight: bold;">1</span>, y: <span style="color: #da8548; font-weight: bold;">2</span>, a: <span style="color: #da8548; font-weight: bold;">3</span>, b: <span style="color: #da8548; font-weight: bold;">4</span> };
   console.log(x); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1</span>
   console.log(y); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">2</span>
   console.log(z); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">{ a: 3, b: 4 }</span>

   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">n</span> = { x, y, ...z };
   console.log(n); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">{ x: 1, y: 2, a: 3, b: 4 }</span>
</pre>
</div>
</div>

<div id="outline-container-org0b0db50" class="outline-4">
<h4 id="org0b0db50"><span class="section-number-4">17.5.1.</span> In iterables (like arrays) :: If we have the two following arrays:</h4>
<div class="outline-text-4" id="text-17-5-1">
<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">arr1</span> = [<span style="color: #98be65;">"a"</span>, <span style="color: #98be65;">"b"</span>, <span style="color: #98be65;">"c"</span>];
    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">arr2</span> = [arr1, <span style="color: #98be65;">"d"</span>, <span style="color: #98be65;">"e"</span>, <span style="color: #98be65;">"f"</span>]; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">[["a", "b", "c"], "d", "e", "f"]</span>
</pre>
</div>

<p>
<i>arr2</i> the first element is an array because <i>arr1</i> is injected as is into <i>arr2</i>. But what we want is <i>arr2</i> to be an array of letters. To do so, we can <i>spread</i> the elements of <i>arr1</i> into <i>arr2</i>.
</p>

<p>
<b>With spread operator</b>:
</p>
<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">arr1</span> = [<span style="color: #98be65;">"a"</span>, <span style="color: #98be65;">"b"</span>, <span style="color: #98be65;">"c"</span>];
    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">arr2</span> = [...arr1, <span style="color: #98be65;">"d"</span>, <span style="color: #98be65;">"e"</span>, <span style="color: #98be65;">"f"</span>]; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">["a", "b", "c", "d", "e", "f"]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org06d9b09" class="outline-4">
<h4 id="org06d9b09"><span class="section-number-4">17.5.2.</span> Function rest parameter</h4>
<div class="outline-text-4" id="text-17-5-2">
<p>
In function parameters, we can use the rest operator to inject parameters into an array we can loop in. There is already an <b>argument</b> object bound to every function that is equal to an array of all the parameters passed into the function.
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">myFunc</span>() {
      <span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #a9a1e1;">arguments</span>.length; i++) {
        console.log(<span style="color: #a9a1e1;">arguments</span>[i]);
      }
    }

    myFunc(<span style="color: #98be65;">"Nick"</span>, <span style="color: #98be65;">"Anderson"</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">12</span>, <span style="color: #da8548; font-weight: bold;">6</span>);
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"Nick"</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"Anderson"</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">12</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">6</span>
</pre>
</div>

<p>
But let&rsquo;s say that we want this function to create a new student with its grades and with its average grade. Wouldn&rsquo;t it be more convenient to extract the first two parameters into two separate variables, and then have all the grades in an array we can iterate over?
</p>

<p>
That&rsquo;s exactly what the rest operator allows us to do!
</p>
<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">createStudent</span>(<span style="color: #dcaeea;">firstName</span>, <span style="color: #dcaeea;">lastName</span>, ...<span style="color: #dcaeea;">grades</span>) {
      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">firstName = "Nick"</span>
      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">lastName = "Anderson"</span>
      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">[10, 12, 6] -- "..." takes all other parameters passed and creates a "grades" array variable that contains them</span>

      <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">avgGrade</span> = grades.reduce((acc, curr) =&gt; acc + curr, <span style="color: #da8548; font-weight: bold;">0</span>) / grades.length; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">computes average grade from grades</span>

      <span style="color: #51afef;">return</span> {
        firstName: firstName,
        lastName: lastName,
        grades: grades,
        avgGrade: avgGrade
      }
    }

    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">student</span> = createStudent(<span style="color: #98be65;">"Nick"</span>, <span style="color: #98be65;">"Anderson"</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #da8548; font-weight: bold;">12</span>, <span style="color: #da8548; font-weight: bold;">6</span>);
    console.log(student);
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">{</span>
    <span style="color: #5B6268;">//   </span><span style="color: #5B6268;">firstName: "Nick",</span>
    <span style="color: #5B6268;">//   </span><span style="color: #5B6268;">lastName: "Anderson",</span>
    <span style="color: #5B6268;">//   </span><span style="color: #5B6268;">grades: [10, 12, 6],</span>
    <span style="color: #5B6268;">//   </span><span style="color: #5B6268;">avgGrade: 9,33</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">}</span>
</pre>
</div>

<blockquote>
<p>
<b>Note:</b> createStudent function is bad because we don&rsquo;t check if grades.length exists or is different from 0. But it&rsquo;s easier to read this way, so I didn&rsquo;t handle this case.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org44c969a" class="outline-4">
<h4 id="org44c969a"><span class="section-number-4">17.5.3.</span> Object properties spreading</h4>
<div class="outline-text-4" id="text-17-5-3">
<p>
For this one, I recommend you read previous explanations about the rest operator on iterables and function parameters.
</p>
<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">myObj</span> = { x: <span style="color: #da8548; font-weight: bold;">1</span>, y: <span style="color: #da8548; font-weight: bold;">2</span>, a: <span style="color: #da8548; font-weight: bold;">3</span>, b: <span style="color: #da8548; font-weight: bold;">4</span> };
    <span style="color: #51afef;">const</span> { x, y, ...z } = myObj; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">object destructuring here</span>
    console.log(x); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1</span>
    console.log(y); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">2</span>
    console.log(z); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">{ a: 3, b: 4 }</span>

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">z is the rest of the object destructured: myObj object minus x and y properties destructured</span>

    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">n</span> = { x, y, ...z };
    console.log(n); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">{ x: 1, y: 2, a: 3, b: 4 }</span>

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Here z object properties are spread into n</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org578340d" class="outline-3">
<h3 id="org578340d"><span class="section-number-3">17.6.</span> Iterators + For..Of</h3>
<div class="outline-text-3" id="text-17-6">
<p>
Iterator objects enable custom iteration like CLR IEnumerable or Java Iterable. Generalize for..in to custom iterator-based iteration with for..of. Don’t require realizing an array, enabling lazy design patterns like LINQ.
</p>

<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">fibonacci</span> = {
     [Symbol.iterator]() {
       <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">pre</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #dcaeea;">cur</span> = <span style="color: #da8548; font-weight: bold;">1</span>;
       <span style="color: #51afef;">return</span> {
         next() {
           [pre, cur] = [cur, pre + cur];
           <span style="color: #51afef;">return</span> { done: <span style="color: #a9a1e1;">false</span>, value: cur }
         }
       }
     }
   }

   <span style="color: #51afef;">for</span> (<span style="color: #51afef;">var</span> <span style="color: #dcaeea;">n</span> <span style="color: #51afef;">of</span> fibonacci) {
     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">truncate the sequence at 1000</span>
     <span style="color: #51afef;">if</span> (n &gt; <span style="color: #da8548; font-weight: bold;">1000</span>)
       <span style="color: #51afef;">break</span>;
     console.log(n);
   }
</pre>
</div>

<p>
Iteration is based on these duck-typed interfaces (using TypeScript type syntax for exposition only):
</p>
<div class="org-src-container">
<pre class="src src-typescript">   <span style="color: #51afef;">interface</span> <span style="color: #ECBE7B;">IteratorResult</span> <span style="color: #51afef;">{</span>
     done: <span style="color: #51afef;">boolean</span>;
     value: <span style="color: #51afef;">any</span>;
   <span style="color: #51afef;">}</span>
   <span style="color: #51afef;">interface</span> <span style="color: #ECBE7B;">Iterator</span> <span style="color: #51afef;">{</span>
     <span style="color: #c678dd;">next</span><span style="color: #c678dd;">()</span>: <span style="color: #ECBE7B;">IteratorResult</span>;
   <span style="color: #51afef;">}</span>
   <span style="color: #51afef;">interface</span> <span style="color: #ECBE7B;">Iterable</span> <span style="color: #51afef;">{</span>
     <span style="color: #c678dd;">[</span>Symbol.iterator<span style="color: #c678dd;">]()</span>: <span style="color: #ECBE7B;">Iterator</span>
   <span style="color: #51afef;">}</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-orgde631f5" class="outline-3">
<h3 id="orgde631f5"><span class="section-number-3">17.7.</span> Symbols</h3>
<div class="outline-text-3" id="text-17-7">
<p>
Symbols enable access control for object state. Symbols allow properties to be keyed by either string (as in ES5) or symbol. Symbols are a new primitive type. Optional description parameter used in debugging - but is not part of identity. Symbols are unique (like gensym), but not private since they are exposed via reflection features like <code>Object.getOwnPropertySymbols</code>.
</p>

<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">MyClass</span> = (<span style="color: #51afef;">function</span>() {
     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">module scoped symbol</span>
     <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">key</span> = Symbol(<span style="color: #98be65;">"key"</span>);

     <span style="color: #51afef;">function</span> <span style="color: #c678dd;">MyClass</span>(<span style="color: #dcaeea;">privateData</span>) {
       <span style="color: #a9a1e1;">this</span>[key] = privateData;
     }

     MyClass.<span style="color: #a9a1e1;">prototype</span> = {
       <span style="color: #c678dd;">doStuff</span>: <span style="color: #51afef;">function</span>() {
         ... <span style="color: #a9a1e1;">this</span>[key] ...
       }
     };

     <span style="color: #51afef;">return</span> MyClass;
   })();

   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">c</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">MyClass</span>(<span style="color: #98be65;">"hello"</span>)
   c[<span style="color: #98be65;">"key"</span>] === <span style="color: #a9a1e1;">undefined</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org52c113c" class="outline-3">
<h3 id="org52c113c"><span class="section-number-3">17.8.</span> Subclassable Built-ins</h3>
<div class="outline-text-3" id="text-17-8">
<p>
In ES6, built-ins like Array, Date and DOM Elements can be subclassed.
</p>

<p>
Object construction for a function named Ctor now uses two-phases (both virtually dispatched):
</p>

<p>
Call Ctor[@@create] to allocate the object, installing any special behavior
Invoke constructor on new instance to initialize
</p>

<p>
The known @@create symbol is available via Symbol.create. Built-ins now expose their @@create explicitly.
</p>

<div class="org-src-container">
<pre class="src src-javascript">   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Pseudo-code of Array</span>
   <span style="color: #51afef;">class</span> Array {
     constructor(...args) { <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">...</span><span style="color: #5B6268;"> */</span> }
     <span style="color: #51afef;">static</span> [Symbol.create]() {
       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Install special [[DefineOwnProperty]]</span>
       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">to magically update 'length'</span>
     }
   }

   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">User code of Array subclass</span>
   <span style="color: #51afef;">class</span> MyArray <span style="color: #51afef;">extends</span> Array {
     constructor(...args) { <span style="color: #51afef;">super</span>(...args); }
   }

   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Two-phase 'new':</span>
   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1) Call @@create to allocate object</span>
   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">2) Invoke constructor on new instance</span>
   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">arr</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">MyArray</span>();
   arr[<span style="color: #da8548; font-weight: bold;">1</span>] = <span style="color: #da8548; font-weight: bold;">12</span>;
   arr.length == <span style="color: #da8548; font-weight: bold;">2</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgacefe9f" class="outline-3">
<h3 id="orgacefe9f"><span class="section-number-3">17.9.</span> Object property shorthand</h3>
<div class="outline-text-3" id="text-17-9">
<p>
When assigning a variable to an object property, if the variable name is equal to the property name, you can do the following:
</p>
<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">10</span>;
   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">myObj</span> = { x };
   console.log(myObj.x) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10</span>
</pre>
</div>

<p>
Usually (pre-ES2015) when you declare a new <i>object literal</i> and want to use variables as object properties values, you would write this kind of code:
</p>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">10</span>;
   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">y</span> = <span style="color: #da8548; font-weight: bold;">20</span>;

   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">myObj</span> = {
     x: x, <span style="color: #5B6268;">// </span><span style="color: #5B6268;">assigning x variable value to myObj.x</span>
     y: y <span style="color: #5B6268;">// </span><span style="color: #5B6268;">assigning y variable value to myObj.y</span>
   };

   console.log(myObj.x) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10</span>
   console.log(myObj.y) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">20</span>
</pre>
</div>

<p>
As you can see, this is quite repetitive because the properties name of myObj are the same as the variable names you want to assign to those properties.
</p>

<p>
With ES2015, when the variable name is the same as the property name, you can do this shorthand:
</p>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">10</span>;
   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">y</span> = <span style="color: #da8548; font-weight: bold;">20</span>;

   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">myObj</span> = {
     x,
     y
   };

   console.log(myObj.x) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10</span>
   console.log(myObj.y) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">20</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org69a014e" class="outline-3">
<h3 id="org69a014e"><span class="section-number-3">17.10.</span> Promises</h3>
<div class="outline-text-3" id="text-17-10">
<p>
   A promise is an object which can be returned synchronously from an asynchronous function
(<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261#3cd0">ref</a>).
</p>

<p>
Promises can be used to avoid <a href="http://callbackhell.com/">callback hell</a>, and they are more and more frequently encountered in modern JavaScript projects.
</p>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">fetchingPosts</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Promise</span>((res, rej) =&gt; {
     $.get(<span style="color: #98be65;">"/posts"</span>)
       .done(posts =&gt; res(posts))
       .fail(err =&gt; rej(err));
     });

     fetchingPosts
       .then(posts =&gt; console.log(posts))
       .<span style="color: #51afef;">catch</span>(err =&gt; console.log(err));
</pre>
</div>

<p>
When you do an <i>Ajax request</i> the response is not synchronous because you want a resource that takes some time to come. It even may never come if the resource you have requested is unavailable for some reason (404). 
</p>

<p>
To handle that kind of situation, ES2015 has given us <i>promises</i>. Promises can have three different states:
</p>
<ul class="org-ul">
<li>Pending</li>
<li>Fulfilled</li>
<li>Rejected</li>
</ul>

<p>
   Let&rsquo;s say we want to use promises to handle an Ajax request to fetch the
resource X.
</p>
</div>

<div id="outline-container-org4bf95c1" class="outline-4">
<h4 id="org4bf95c1"><span class="section-number-4">17.10.1.</span> Create the promise</h4>
<div class="outline-text-4" id="text-17-10-1">
<p>
We firstly are going to create a promise. We will use the jQuery get method to do our Ajax request to X.
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">xFetcherPromise</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Promise</span>( <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Create promise using "new" keyword and store it into a variable</span>
      <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">resolve</span>, <span style="color: #dcaeea;">reject</span>) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Promise constructor takes a function parameter which has resolve and reject parameters itself</span>
        $.get(<span style="color: #98be65;">"X"</span>) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Launch the Ajax request</span>
          .done(<span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">X</span>) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Once the request is done...</span>
            resolve(X); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">... resolve the promise with the X value as parameter</span>
          })
          .fail(<span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">error</span>) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">If the request has failed...</span>
            reject(error); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">... reject the promise with the error as parameter</span>
          });
      }
    )
</pre>
</div>

<p>
As seen in the above sample, the Promise object takes an <i>executor</i> function which takes two parameters <b>resolve</b> and <b>reject</b>. Those parameters are functions which when called are going to move the promise <i>pending</i> state to respectively a <i>fulfilled</i> and <i>rejected</i> state.
</p>

<p>
The promise is in pending state after instance creation and its <i>executor</i> function is executed immediately. Once one of the function <i>resolve</i> or <i>reject</i> is called in the <i>executor</i> function, the promise will call its associated handlers.
</p>
</div>
</div>

<div id="outline-container-orgeb242db" class="outline-4">
<h4 id="orgeb242db"><span class="section-number-4">17.10.2.</span> Promise handlers usage</h4>
<div class="outline-text-4" id="text-17-10-2">
<p>
To get the promise result (or error), we must attach to it handlers by doing the following:
</p>

<div class="org-src-container">
<pre class="src src-js">    xFetcherPromise
      .then(<span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">X</span>) {
        console.log(X);
      })
      .<span style="color: #51afef;">catch</span>(<span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">err</span>) {
        console.log(err)
      })
</pre>
</div>

<p>
If the promise succeeds, <i>resolve</i> is executed and the function passed as <code>.then</code> parameter is executed.
</p>

<p>
If it fails, <i>reject</i> is executed and the function passed as <code>.catch</code> parameter is executed.
</p>

<blockquote>
<p>
<b>Note :</b> If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#Description">(Ref: MDN)</a>
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-org2132163" class="outline-3">
<h3 id="org2132163"><span class="section-number-3">17.11.</span> Template literals</h3>
<div class="outline-text-3" id="text-17-11">
<p>
Template literals is an <a href="https://en.wikipedia.org/wiki/String_interpolation"><i>expression interpolation</i></a> for single and multiple-line strings.
</p>

<p>
In other words, it is a new string syntax in which you can conveniently use any JavaScript expressions (variables for instance).
</p>
<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">name</span> = <span style="color: #98be65;">"Nick"</span>;
   <span style="color: #98be65;">`Hello ${name}, the following expression is equal to four : ${2+2}`</span>;

   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Hello Nick, the following expression is equal to four: 4</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-orgc9cb5ba" class="outline-3">
<h3 id="orgc9cb5ba"><span class="section-number-3">17.12.</span> Tagged template literals</h3>
<div class="outline-text-3" id="text-17-12">
<p>
Template tags are <i>functions that can be prefixed to a /template literal</i>. When a function is called this way, the first parameter is an array of the <i>strings</i> that appear between the template&rsquo;s interpolated variables, and the subsequent parameters are the interpolated values. Use a spread operator <code>...</code> to capture all of them. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals">(Ref: MDN)</a>.
</p>

<blockquote>
<p>
<b>Note :</b> A famous library named <a href="https://www.styled-components.com/">styled-components</a> heavily relies on this feature.
</p>
</blockquote>

<p>
Below is a toy example on how they work.
</p>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">function</span> <span style="color: #c678dd;">highlight</span>(<span style="color: #dcaeea;">strings</span>, ...<span style="color: #dcaeea;">values</span>) {
     <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">interpolation</span> = strings.reduce((prev, current) =&gt; {
       <span style="color: #51afef;">return</span> prev + current + (values.length ? <span style="color: #98be65;">"&lt;mark&gt;"</span> + values.shift() + <span style="color: #98be65;">"&lt;/mark&gt;"</span> : <span style="color: #98be65;">""</span>);
     }, <span style="color: #98be65;">""</span>);

     <span style="color: #51afef;">return</span> interpolation;
   }

   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">condiment</span> = <span style="color: #98be65;">"jam"</span>;
   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">meal</span> = <span style="color: #98be65;">"toast"</span>;

   highlight<span style="color: #98be65;">`I like ${condiment} on ${meal}.`</span>;
   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"I like &lt;mark&gt;jam&lt;/mark&gt; on &lt;mark&gt;toast&lt;/mark&gt;."</span>
</pre>
</div>

<p>
A more interesting example:
</p>
<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">function</span> <span style="color: #c678dd;">comma</span>(<span style="color: #dcaeea;">strings</span>, ...<span style="color: #dcaeea;">values</span>) {
     <span style="color: #51afef;">return</span> strings.reduce((prev, next) =&gt; {
       <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">value</span> = values.shift() || [];
       value = value.join(<span style="color: #98be65;">", "</span>);
       <span style="color: #51afef;">return</span> prev + next + value;
     }, <span style="color: #98be65;">""</span>);
   }

   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">snacks</span> = [<span style="color: #98be65;">'apples'</span>, <span style="color: #98be65;">'bananas'</span>, <span style="color: #98be65;">'cherries'</span>];
   comma<span style="color: #98be65;">`I like ${snacks} to snack on.`</span>;
   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"I like apples, bananas, cherries to snack on."</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8a04934" class="outline-3">
<h3 id="org8a04934"><span class="section-number-3">17.13.</span> Imports / Exports</h3>
<div class="outline-text-3" id="text-17-13">
<p>
ES6 modules are used to access variables or functions in a module explicitly exported by the modules it imports.
</p>

<p>
It is recommended to take a look at MDN resources on import/export (see external resources below), it is both straightforward and complete.
</p>
</div>

<div id="outline-container-org891dab5" class="outline-4">
<h4 id="org891dab5"><span class="section-number-4">17.13.1.</span> Named exports</h4>
<div class="outline-text-4" id="text-17-13-1">
<p>
Named exports are used to export several values from a module.
</p>

<blockquote>
<p>
<b>Note :</b> You can only name-export <a href="https://en.wikipedia.org/wiki/First-class_citizen">first-class citizens</a> that have a name.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">mathConstants.js</span>
    <span style="color: #51afef;">export</span> <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">pi</span> = <span style="color: #da8548; font-weight: bold;">3.14</span>;
    <span style="color: #51afef;">export</span> <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">exp</span> = <span style="color: #da8548; font-weight: bold;">2.7</span>;
    <span style="color: #51afef;">export</span> <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">alpha</span> = <span style="color: #da8548; font-weight: bold;">0.35</span>;

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">-------------</span>

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">myFile.js</span>
    <span style="color: #51afef;">import</span> { pi, exp } from <span style="color: #98be65;">'./mathConstants.js'</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Named import -- destructuring-like syntax</span>
    console.log(pi) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">3.14</span>
    console.log(exp) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">2.7</span>

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">-------------</span>

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">mySecondFile.js</span>
    <span style="color: #51afef;">import</span> * as constants from <span style="color: #98be65;">'./mathConstants.js'</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Inject all exported values into constants variable</span>
    console.log(constants.pi) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">3.14</span>
    console.log(constants.exp) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">2.7</span>
</pre>
</div>

<p>
While named imports looks like <i>destructuring</i>, they have a different syntax and are not the same. They don&rsquo;t support default values nor <i>deep</i> destructuring.
</p>

<p>
Besides, you can do aliases but the syntax is different from the one used in destructuring:
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">import</span> { foo as bar } from <span style="color: #98be65;">'myFile.js'</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">foo is imported and injected into a new bar variable</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org70b3511" class="outline-4">
<h4 id="org70b3511"><span class="section-number-4">17.13.2.</span> Default import / export</h4>
<div class="outline-text-4" id="text-17-13-2">
<p>
Concerning the default export, there is only a single default export per module. A default export can be a function, a class, an object or anything else. This value is considered the &ldquo;main&rdquo; exported value since it will be the simplest to import. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export#Description">Ref: MDN</a>
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">coolNumber.js</span>
    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">ultimateNumber</span> = <span style="color: #da8548; font-weight: bold;">42</span>;
    <span style="color: #51afef;">export</span> <span style="color: #51afef;">default</span> ultimateNumber;

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">------------</span>

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">myFile.js</span>
    <span style="color: #51afef;">import</span> number from <span style="color: #98be65;">'./coolNumber.js'</span>;
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Default export, independently from its name, is automatically injected into number variable;</span>
    console.log(number) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">42</span>
</pre>
</div>

<p>
Function exporting:
</p>
<div class="org-src-container">
<pre class="src src-js">    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">sum.js</span>
    <span style="color: #51afef;">export</span> <span style="color: #51afef;">default</span> <span style="color: #51afef;">function</span> sum(<span style="color: #dcaeea;">x</span>, <span style="color: #dcaeea;">y</span>) {
      <span style="color: #51afef;">return</span> x + y;
    }
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">-------------</span>

    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">myFile.js</span>
    <span style="color: #51afef;">import</span> sum from <span style="color: #98be65;">'./sum.js'</span>;
    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">result</span> = sum(<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>);
    console.log(result) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">3</span>
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-orgf44c2b0" class="outline-3">
<h3 id="orgf44c2b0"><span class="section-number-3">17.14.</span> Classes in ES6</h3>
<div class="outline-text-3" id="text-17-14">
<p>
JavaScript is a <a href="https://en.wikipedia.org/wiki/Prototype-based_programming">prototype-based</a> language (whereas Java is <a href="https://en.wikipedia.org/wiki/Class-based_programming">class-based</a> language, for instance). ES6 has introduced JavaScript classes which are meant to be a syntactic sugar for prototype-based inheritance and <b>not</b> a new class-based inheritance model (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">ref</a>).
</p>

<p>
The word <i>class</i> is indeed error prone if you are familiar with classes in other languages. If you do, avoid assuming how JavaScript classes work on this basis and consider it an entirely different notion.
</p>


<p>
Before ES6, prototype syntax: 
</p>
<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">Person</span> = <span style="color: #51afef;">function</span>(<span style="color: #dcaeea;">name</span>, <span style="color: #dcaeea;">age</span>) {
     <span style="color: #a9a1e1;">this</span>.name = name;
     <span style="color: #a9a1e1;">this</span>.age = age;
   }
   Person.<span style="color: #a9a1e1;">prototype</span>.stringSentence = <span style="color: #51afef;">function</span>() {
     <span style="color: #51afef;">return</span> <span style="color: #98be65;">"Hello, my name is "</span> + <span style="color: #a9a1e1;">this</span>.name + <span style="color: #98be65;">" and I'm "</span> + <span style="color: #a9a1e1;">this</span>.age;
   }
</pre>
</div>

<p>
With ES6 class syntax:
</p>
<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">class</span> Person {
     constructor(name, age) {
       <span style="color: #a9a1e1;">this</span>.name = name;
       <span style="color: #a9a1e1;">this</span>.age = age;
     }

     stringSentence() {
       <span style="color: #51afef;">return</span> <span style="color: #98be65;">"Hello, my name is "</span> + <span style="color: #a9a1e1;">this</span>.name + <span style="color: #98be65;">" and I'm "</span> + <span style="color: #a9a1e1;">this</span>.age;
     }
   }
   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">myPerson</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Person</span>(<span style="color: #98be65;">"Manu"</span>, <span style="color: #da8548; font-weight: bold;">23</span>);
   console.log(myPerson.age) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">23</span>
   console.log(myPerson.stringSentence()) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"Hello, my name is Manu and I'm 23</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7190823" class="outline-3">
<h3 id="org7190823"><span class="section-number-3">17.15.</span> <code>Extends</code> and <code>super</code> keywords</h3>
<div class="outline-text-3" id="text-17-15">
<p>
The <code>extends</code> keyword is used in class declarations or class expressions to create a class which is a child of another class (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends">Ref: MDN</a>). The subclass inherits all the properties of the superclass and additionally can add new properties or modify the inherited ones.
</p>

<p>
The <code>super</code> keyword is used to call functions on an object&rsquo;s parent, including its constructor.
</p>
<ul class="org-ul">
<li><code>super</code> keyword must be used before the <code>this</code> keyword is used in constructor</li>
<li>Invoking <code>super()</code> calls the parent class constructor. If you want to pass some arguments in a class&rsquo;s constructor to its parent&rsquo;s constructor, you call it with <code>super(arguments)</code>.</li>
<li>If the parent class have a method (even static) called <code>X</code>, you can use <code>super.X()</code> to call it in a child class.</li>
</ul>
<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">class</span> Polygon {
     constructor(height, width) {
       <span style="color: #a9a1e1;">this</span>.name = <span style="color: #98be65;">'Polygon'</span>;
       <span style="color: #a9a1e1;">this</span>.height = height;
       <span style="color: #a9a1e1;">this</span>.width = width;
     }

     getHelloPhrase() {
       <span style="color: #51afef;">return</span> <span style="color: #98be65;">`Hi, I am a ${this.name}`</span>;
     }
   }

   <span style="color: #51afef;">class</span> Square <span style="color: #51afef;">extends</span> Polygon {
     constructor(length) {
       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Here, it calls the parent class' constructor with lengths</span>
       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">provided for the Polygon's width and height</span>
       <span style="color: #51afef;">super</span>(length, length);
       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Note: In derived classes, super() must be called before you</span>
       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">can use 'this'. Leaving this out will cause a reference error.</span>
       <span style="color: #a9a1e1;">this</span>.name = <span style="color: #98be65;">'Square'</span>;
       <span style="color: #a9a1e1;">this</span>.length = length;
     }

     getCustomHelloPhrase() {
       <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">polygonPhrase</span> = <span style="color: #51afef;">super</span>.getHelloPhrase(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">accessing parent method with super.X() syntax</span>
       <span style="color: #51afef;">return</span> <span style="color: #98be65;">`${polygonPhrase} with a length of ${this.length}`</span>;
     }

     get area() {
       <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">this</span>.height * <span style="color: #a9a1e1;">this</span>.width;
     }
   }

   <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">mySquare</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Square</span>(<span style="color: #da8548; font-weight: bold;">10</span>);
   console.log(mySquare.area) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">100</span>
   console.log(mySquare.getHelloPhrase()) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">'Hi, I am a Square' -- Square inherits from Polygon and has access to its methods</span>
   console.log(mySquare.getCustomHelloPhrase()) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">'Hi, I am a Square with a length of 10'</span>
</pre>
</div>

<p>
<b>Note :</b> If we had tried to use <code>this</code> before calling <code>super()</code> in Square class, a ReferenceError would have been raised:
</p>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">class</span> Square <span style="color: #51afef;">extends</span> Polygon {
     constructor(length) {
       <span style="color: #a9a1e1;">this</span>.height; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">ReferenceError, super needs to be called first!</span>

       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Here, it calls the parent class' constructor with lengths</span>
       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">provided for the Polygon's width and height</span>
       <span style="color: #51afef;">super</span>(length, length);

       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Note: In derived classes, super() must be called before you</span>
       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">can use 'this'. Leaving this out will cause a reference error.</span>
       <span style="color: #a9a1e1;">this</span>.name = <span style="color: #98be65;">'Square'</span>;
     }
   }
</pre>
</div>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">class</span> SkinnedMesh <span style="color: #51afef;">extends</span> THREE.Mesh {
     constructor(geometry, materials) {
       <span style="color: #51afef;">super</span>(geometry, materials);

       <span style="color: #a9a1e1;">this</span>.idMatrix = SkinnedMesh.defaultMatrix();
       <span style="color: #a9a1e1;">this</span>.bones = [];
       <span style="color: #a9a1e1;">this</span>.boneMatrices = [];
       <span style="color: #5B6268;">//</span><span style="color: #5B6268;">...</span>
     }
     update(camera) {
       <span style="color: #5B6268;">//</span><span style="color: #5B6268;">...</span>
       <span style="color: #51afef;">super</span>.update();
     }
     get boneCount() {
       <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">this</span>.bones.length;
     }
     set matrixType(matrixType) {
       <span style="color: #a9a1e1;">this</span>.idMatrix = SkinnedMesh[matrixType]();
     }
     <span style="color: #51afef;">static</span> defaultMatrix() {
       <span style="color: #51afef;">return</span> <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">THREE.Matrix4</span>();
     }
   }
</pre>
</div>
</div>
</div>


<div id="outline-container-orgaa42864" class="outline-3">
<h3 id="orgaa42864"><span class="section-number-3">17.16.</span> Async Await</h3>
<div class="outline-text-3" id="text-17-16">
<p>
In addition to <code>promises</code>, there is a new syntax you might encounter to handle asynchronous code named <i>async / await</i>.
</p>

<p>
   The purpose of async/await functions is to simplify the behavior of using promises synchronously and to perform some behavior on a group of Promises. Just as Promises are similar to structured callbacks, async/await is similar to combining generators and promises. Async
functions <i>always</i> returns a Promise. (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">Ref: MDN</a>)
</p>

<blockquote>
<p>
<b>Note :</b> You must understand what promises are and how they work before trying to understand async / await since they rely on it.
</p>
</blockquote>

<blockquote>
<p>
<b>Note 2:</b> <a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9#f3f0"><i>await</i> must be used in an <i>async</i> function</a>, which means that you can&rsquo;t use await in the top level of our code since that is not inside an async function.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">async</span> <span style="color: #51afef;">function</span> getGithubUser(<span style="color: #dcaeea;">username</span>) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">async keyword allows usage of await in the function and means function returns a promise</span>
     <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">response</span> = <span style="color: #51afef;">await</span> fetch(<span style="color: #98be65;">`https://api.github.com/users/${username}`</span>); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Execution is paused here until the Promise returned by fetch is resolved</span>
     <span style="color: #51afef;">return</span> response.json();
   }

   getGithubUser(<span style="color: #98be65;">'mbeaudru'</span>)
     .then(user =&gt; console.log(user)) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">logging user response - cannot use await syntax since this code isn't in async function</span>
     .<span style="color: #51afef;">catch</span>(err =&gt; console.log(err)); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">if an error is thrown in our async function, we will catch it here</span>
</pre>
</div>

<p>
<i>Async / Await</i> is built on promises but they allow a more imperative style of code.
</p>

<p>
The <i>async</i> operator marks a function as asynchronous and will always return a <i>Promise</i>. You can use the <i>await</i> operator in an <i>async</i> function to pause execution on that line until the returned Promise from the expression either resolves or rejects.
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">async</span> <span style="color: #51afef;">function</span> myFunc() {
      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">we can use await operator because this function is async</span>
      <span style="color: #51afef;">return</span> <span style="color: #98be65;">"hello world"</span>;
    }

    myFunc().then(msg =&gt; console.log(msg)) <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"hello world" -- myFunc's return value is turned into a promise because of async operator</span>
</pre>
</div>

<p>
When the <i>return</i> statement of an async function is reached, the Promise is fulfilled with the value returned. If an error is thrown inside an async function, the Promise state will turn to <i>rejected</i>. If no value is returned from an async function, a Promise is still returned and resolves with no value when execution of the async function is complete.
</p>

<p>
<i>await</i> operator is used to wait for a <i>Promise</i> to be fulfilled and can only be used inside an <i>async</i> function body. When encountered, the code execution is paused until the promise is fulfilled.
</p>

<blockquote>
<p>
<b>Note :</b> <i>fetch</i> is a function that returns a Promise that allows to do an AJAX request
</p>
</blockquote>

<p>
Let&rsquo;s see how we could fetch a github user with promises first:
</p>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">function</span> <span style="color: #c678dd;">getGithubUser</span>(<span style="color: #dcaeea;">username</span>) {
     <span style="color: #51afef;">return</span> fetch(<span style="color: #98be65;">`https://api.github.com/users/${username}`</span>).then(response =&gt; response.json());
   }

   getGithubUser(<span style="color: #98be65;">'mbeaudru'</span>)
     .then(user =&gt; console.log(user))
     .<span style="color: #51afef;">catch</span>(err =&gt; console.log(err));
</pre>
</div>

<p>
Here&rsquo;s the <i>async / await</i> equivalent:
</p>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">async</span> <span style="color: #51afef;">function</span> getGithubUser(<span style="color: #dcaeea;">username</span>) { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">promise + await keyword usage allowed</span>
     <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">response</span> = <span style="color: #51afef;">await</span> fetch(<span style="color: #98be65;">`https://api.github.com/users/${username}`</span>); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Execution stops here until fetch promise is fulfilled</span>
     <span style="color: #51afef;">return</span> response.json();
   }

   getGithubUser(<span style="color: #98be65;">'mbeaudru'</span>)
     .then(user =&gt; console.log(user))
     .<span style="color: #51afef;">catch</span>(err =&gt; console.log(err));
</pre>
</div>

<p>
<i>async / await</i> syntax is particularly convenient when you need to chain promises that are interdependent.
</p>

<p>
For instance, if you need to get a token in order to be able to fetch a blog post on a database and then the author informations:
</p>

<blockquote>
<p>
<b>Note :</b> <i>await</i> expressions needs to be wrapped in parentheses to call its resolved value&rsquo;s methods and properties on the same line.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">async</span> <span style="color: #51afef;">function</span> fetchPostById(<span style="color: #dcaeea;">postId</span>) {
     <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">token</span> = (<span style="color: #51afef;">await</span> fetch(<span style="color: #98be65;">'token_url'</span>)).json().token;
     <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">post</span> = (<span style="color: #51afef;">await</span> fetch(<span style="color: #98be65;">`/posts/${postId}?token=${token}`</span>)).json();
     <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">author</span> = (<span style="color: #51afef;">await</span> fetch(<span style="color: #98be65;">`/users/${post.authorId}`</span>)).json();

     post.author = author;
     <span style="color: #51afef;">return</span> post;
   }

   fetchPostById(<span style="color: #98be65;">'gzIrzeo64'</span>)
     .then(post =&gt; console.log(post))
     .<span style="color: #51afef;">catch</span>(err =&gt; console.log(err));
</pre>
</div>
</div>

<div id="outline-container-org2342398" class="outline-4">
<h4 id="org2342398"><span class="section-number-4">17.16.1.</span> Error handling</h4>
<div class="outline-text-4" id="text-17-16-1">
<p>
Unless we add <i>try / catch</i> blocks around <i>await</i> expressions, uncaught exceptions &#x2013; regardless of whether they were thrown in the body of your <i>async</i> function or while it&rsquo;s suspended during <i>await</i> &#x2013; will reject the promise returned by the <i>async</i> function. Using the <code>throw</code> statement in an async function is the same as returning a Promise that rejects. <a href="https://ponyfoo.com/articles/understanding-javascript-async-await#error-handling">(Ref: PonyFoo)</a>.
</p>

<blockquote>
<p>
<b>Note :</b> Promises behave the same!
</p>
</blockquote>

<p>
With promises, here is how you would handle the error chain:
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">getUser</span>() { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">This promise will be rejected!</span>
      <span style="color: #51afef;">return</span> <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Promise</span>((res, rej) =&gt; rej(<span style="color: #98be65;">"User not found !"</span>));
    }

    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">getAvatarByUsername</span>(<span style="color: #dcaeea;">userId</span>) {
      <span style="color: #51afef;">return</span> getUser(userId).then(user =&gt; user.avatar);
    }

    <span style="color: #51afef;">function</span> <span style="color: #c678dd;">getUserAvatar</span>(<span style="color: #dcaeea;">username</span>) {
      <span style="color: #51afef;">return</span> getAvatarByUsername(username).then(avatar =&gt; ({ username, avatar }));
    }

    getUserAvatar(<span style="color: #98be65;">'mbeaudru'</span>)
      .then(res =&gt; console.log(res))
      .<span style="color: #51afef;">catch</span>(err =&gt; console.log(err)); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"User not found !"</span>
</pre>
</div>

<p>
The equivalent with <i>async / await</i>:
</p>

<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">async</span> <span style="color: #51afef;">function</span> getUser() { <span style="color: #5B6268;">// </span><span style="color: #5B6268;">The returned promise will be rejected!</span>
      <span style="color: #51afef;">throw</span> <span style="color: #98be65;">"User not found !"</span>;
    }

    <span style="color: #51afef;">async</span> <span style="color: #51afef;">function</span> getAvatarByUsername(<span style="color: #dcaeea;">userId</span>) =&gt; {
      <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">user</span> = <span style="color: #51afef;">await</span> getUser(userId);
      <span style="color: #51afef;">return</span> user.avatar;
    }

    <span style="color: #51afef;">async</span> <span style="color: #51afef;">function</span> getUserAvatar(<span style="color: #dcaeea;">username</span>) {
      <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">avatar</span> = <span style="color: #51afef;">await</span> getAvatarByUsername(username);
      <span style="color: #51afef;">return</span> { username, avatar };
    }

    getUserAvatar(<span style="color: #98be65;">'mbeaudru'</span>)
      .then(res =&gt; console.log(res))
      .<span style="color: #51afef;">catch</span>(err =&gt; console.log(err)); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">"User not found !"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7eca713" class="outline-3">
<h3 id="org7eca713"><span class="section-number-3">17.17.</span> Generators</h3>
<div class="outline-text-3" id="text-17-17">
<p>
   Another way to write the <code>downToOne</code> function is to use a Generator. To instantiate a <code>Generator</code> object, one must use the <code>function *</code> declaration. Generators are functions that can be exited and later re-entered with its context (variable bindings) saved across
re-entrances.
</p>

<p>
For example, the <code>downToOne</code> function above can be rewritten as:  
</p>
<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">function</span> * <span style="color: #c678dd;">downToOne</span>(n) {
     <span style="color: #51afef;">for</span> (<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">i</span> = n; i &gt; <span style="color: #da8548; font-weight: bold;">0</span>; --i) {
       <span style="color: #51afef;">yield</span> i;
     }
   }

   [...downToOne(<span style="color: #da8548; font-weight: bold;">5</span>)] <span style="color: #5B6268;">//</span><span style="color: #5B6268;">[ 5, 4, 3, 2, 1 ]</span>
</pre>
</div>

<p>
Generators return an iterable object. When the iterator&rsquo;s <code>next()</code> function is called, it is executed until the first <code>yield</code> expression, which specifies the value to be returned from the iterator or with <code>yield*</code>, which delegates to another generator function. When a <code>return</code> expression is called in the generator, it will mark the generator as done and pass back as the return value. Further calls to <code>next()</code> will not return any new values.
</p>

<p>
<b>Sample code</b>
</p>
<div class="org-src-container">
<pre class="src src-js">   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Yield Example</span>
   <span style="color: #51afef;">function</span> * <span style="color: #c678dd;">idMaker</span>() {
     <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">index</span> = <span style="color: #da8548; font-weight: bold;">0</span>;
     <span style="color: #51afef;">while</span> (index &lt; <span style="color: #da8548; font-weight: bold;">2</span>) {
       <span style="color: #51afef;">yield</span> index;
       index = index + <span style="color: #da8548; font-weight: bold;">1</span>;
     }
   }

   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">gen</span> = idMaker();

   gen.next().value; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0</span>
   gen.next().value; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">1</span>
   gen.next().value; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">undefined</span>
</pre>
</div>

<p>
The <code>yield*</code> expression enables a generator to call another generator function during iteration.
</p>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Yield * Example</span>
   <span style="color: #51afef;">function</span> * <span style="color: #c678dd;">genB</span>(i) {
     <span style="color: #51afef;">yield</span> i + <span style="color: #da8548; font-weight: bold;">1</span>;
     <span style="color: #51afef;">yield</span> i + <span style="color: #da8548; font-weight: bold;">2</span>;
     <span style="color: #51afef;">yield</span> i + <span style="color: #da8548; font-weight: bold;">3</span>;
   }

   <span style="color: #51afef;">function</span> * <span style="color: #c678dd;">genA</span>(i) {
     <span style="color: #51afef;">yield</span> i;
     <span style="color: #51afef;">yield</span>* genB(i);
     <span style="color: #51afef;">yield</span> i + <span style="color: #da8548; font-weight: bold;">10</span>;
   }

   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">gen</span> = genA(<span style="color: #da8548; font-weight: bold;">10</span>);

   gen.next().value; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">10</span>
   gen.next().value; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">11</span>
   gen.next().value; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">12</span>
   gen.next().value; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">13</span>
   gen.next().value; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">20</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Generator Return Example</span>
   <span style="color: #51afef;">function</span>* <span style="color: #c678dd;">yieldAndReturn</span>() {
     <span style="color: #51afef;">yield</span> <span style="color: #98be65;">"Y"</span>;
     <span style="color: #51afef;">return</span> <span style="color: #98be65;">"R"</span>;
     <span style="color: #51afef;">yield</span> <span style="color: #98be65;">"unreachable"</span>;
   }

   <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">gen</span> = yieldAndReturn()
   gen.next(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">{ value: "Y", done: false }</span>
   gen.next(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">{ value: "R", done: true }</span>
   gen.next(); <span style="color: #5B6268;">// </span><span style="color: #5B6268;">{ value: undefined, done: true }</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdf093e5" class="outline-3">
<h3 id="orgdf093e5"><span class="section-number-3">17.18.</span> Static Methods</h3>
<div class="outline-text-3" id="text-17-18">
<p>
The <code>static</code> keyword is used in classes to declare static methods. Static methods are functions in a class that belongs to the class object and are not available to any instance of that class.
</p>

<div class="org-src-container">
<pre class="src src-js">   <span style="color: #51afef;">class</span> Repo{
     <span style="color: #51afef;">static</span> getName() {
       <span style="color: #51afef;">return</span> <span style="color: #98be65;">"Repo name is modern-js-cheatsheet"</span>
     }
   }

   <span style="color: #5B6268;">//</span><span style="color: #5B6268;">Note that we did not have to create an instance of the Repo class</span>
   console.log(Repo.getName()) <span style="color: #5B6268;">//</span><span style="color: #5B6268;">Repo name is modern-js-cheatsheet</span>

   <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">r</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Repo</span>();
   console.log(r.getName()) <span style="color: #5B6268;">//</span><span style="color: #5B6268;">Uncaught TypeError: repo.getName is not a function</span>
</pre>
</div>

<p>
Static methods can be called within another static method by using the <code>this</code> keyword, this doesn&rsquo;t work for non-static methods though. Non-static methods cannot directly access static methods using the <code>this</code> keyword.
</p>
</div>

<div id="outline-container-org031d719" class="outline-4">
<h4 id="org031d719"><span class="section-number-4">17.18.1.</span> Calling other static methods from a static method.</h4>
<div class="outline-text-4" id="text-17-18-1">
<p>
To call a static method from another static method, the <code>this</code> keyword can be used like so;
</p>
<div class="org-src-container">
<pre class="src src-js">    <span style="color: #51afef;">class</span> Repo{
      <span style="color: #51afef;">static</span> getName() {
        <span style="color: #51afef;">return</span> <span style="color: #98be65;">"Repo name is modern-js-cheatsheet"</span>
      }

      <span style="color: #51afef;">static</span> modifyName(){
        <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">this</span>.getName() + <span style="color: #98be65;">'-added-this'</span>
      }
    }

    console.log(Repo.modifyName()) <span style="color: #5B6268;">//</span><span style="color: #5B6268;">Repo name is modern-js-cheatsheet-added-this</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf95925c" class="outline-4">
<h4 id="orgf95925c"><span class="section-number-4">17.18.2.</span> Calling static methods from non-static methods.</h4>
<div class="outline-text-4" id="text-17-18-2">
<p>
Non-static methods can call static methods in 2 ways; 
</p>
<ol class="org-ol">
<li><p>
Using the class name.
To get access to a static method from a non-static method we use the class name and call the static method like a property. e.g <code>ClassName.StaticMethodName</code>
</p>
<div class="org-src-container">
<pre class="src src-js">       <span style="color: #51afef;">class</span> Repo{
         <span style="color: #51afef;">static</span> getName() {
         <span style="color: #51afef;">return</span> <span style="color: #98be65;">"Repo name is modern-js-cheatsheet"</span>
         }

         useName(){
           <span style="color: #51afef;">return</span> Repo.getName() + <span style="color: #98be65;">' and it contains some really important stuff'</span>
         }
       }

       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">we need to instantiate the class to use non-static methods</span>
       <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">r</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Repo</span>()
       console.log(r.useName()) <span style="color: #5B6268;">//</span><span style="color: #5B6268;">Repo name is modern-js-cheatsheet and it contains some really important stuff</span>
</pre>
</div></li>

<li><p>
Using the constructor
Static methods can be called as properties on the constructor object.
</p>
<div class="org-src-container">
<pre class="src src-js">       <span style="color: #51afef;">class</span> Repo{
         <span style="color: #51afef;">static</span> getName() {
           <span style="color: #51afef;">return</span> <span style="color: #98be65;">"Repo name is modern-js-cheatsheet"</span>
         }

         useName(){
           <span style="color: #5B6268;">//</span><span style="color: #5B6268;">Calls the static method as a property of the constructor</span>
           <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">this</span>.constructor.getName() + <span style="color: #98be65;">' and it contains some really important stuff'</span>
         }
       }

       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">we need to instantiate the class to use non-static methods</span>
       <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">r</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Repo</span>()
       console.log(r.useName()) <span style="color: #5B6268;">//</span><span style="color: #5B6268;">Repo name is modern-js-cheatsheet and it contains some really important stuff</span>
</pre>
</div></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgdb7cd70" class="outline-3">
<h3 id="orgdb7cd70"><span class="section-number-3">17.19.</span> Binary and Octal Literals</h3>
<div class="outline-text-3" id="text-17-19">
<p>
Two new numeric literal forms are added for binary (b) and octal (o).
</p>
<div class="org-src-container">
<pre class="src src-javascript">   0b111110111 === <span style="color: #da8548; font-weight: bold;">503</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">true</span>
   0o767 === <span style="color: #da8548; font-weight: bold;">503</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">true</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Advanced Web Design - <a href="https://www.finki.ukim.mk/">https://www.finki.ukim.mk/</a></p>
<p class="date">Created: 2025</p>
</div>
</body>
</html>
